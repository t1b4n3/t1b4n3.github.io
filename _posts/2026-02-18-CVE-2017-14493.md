---
layout: post
title:
description:
date: 2026-02-18
categories:
tags:
---
# [CVE-2017-14493] Exploiting Stack Based Buffer Overflow in dnsmasq 


[CVE Description:](https://nvd.nist.gov/vuln/detail/cve-2017-14493) Stack-based buffer overflow in dnsmasq before 2.78 allows remote attackers to cause a denial of service (crash) or execute arbitrary code via a crafted DHCPv6 request.

## Vulnerability Analyses

To find where the vulnerability is lets run they program while its attached to a debugger and run the [PoC](https://github.com/google/security-research-pocs/blob/master/vulnerabilities/dnsmasq/CVE-2017-14493.py) and analyse it from there.

before running the program I will just setup my interface to use a static IPv6 address.

```sh
sudo ip -6 addr add 2001:db8::1/64 dev wlp4s0
```

```gdb
run -d -i wlp4s0 --dhcp-range=2001:db8::10,2001:db8::ae,64 --enable-ra
```

![GDB](/assets/images/research/cve-2017-14493/running_gdb.png)

In another terminal run the [PoC](https://github.com/google/security-research-pocs/blob/master/vulnerabilities/dnsmasq/CVE-2017-14493.py)

```sh
./poc.py 2001:db8::1 547
[+] sending 120 bytes to 2001:db8::2:547
```

![segfault](/assets/images/research/cve-2017-14493/segfault.png)
As we can see that we got a segfault in the `dhcp6_reply()`.

```c
unsigned short 
dhcp6_reply(struct dhcp_context *context, int interface, char *iface_name,
        struct in6_addr *fallback, struct in6_addr *ll_addr, struct in6_addr *ula_addr,
        size_t sz, struct in6_addr *client_addr, time_t now)
{
        struct dhcp_vendor *vendor;
        int msg_type;
        struct state state;
        if (sz <= 4) return 0;
        msg_type = *((unsigned char *)daemon->dhcp_packet.iov_base);
        /* Mark these so we only match each at most once, to avoid tangled linked lists */
        for (vendor = daemon->dhcp_vendors; vendor; vendor = vendor->next)
                vendor->netid.next = &vendor->netid;
        
        reset_counter();
        state.context = context;
        state.interface = interface;
        state.iface_name = iface_name;
        state.fallback = fallback;
        state.ll_addr = ll_addr;
        state.ula_addr = ula_addr;
        state.mac_len = 0;
        state.tags = NULL;
        state.link_address = NULL;

        if (dhcp6_maybe_relay(&state, daemon->dhcp_packet.iov_base, sz, client_addr,
                N6_IS_ADDR_MULTICAST(client_addr), now))
                return msg_type == DHCP6RELAYFORW ? DHCPV6_SERVER_PORT : DHCPV6_CLIENT_PORT;
        return 0;
}
```

When looking at function, there is nothing really interesting, so my first thought was that there vulnerability is in another function but affects the stack of this function. The only function that has a argument that resides in the `dhcp6_reply` is `dhcp6_maybe_relay` and the variable name is `state`. 

Here is the `state struct`: 

```c
  
struct state {
	unsigned char *clid;
	int clid_len, iaid, ia_type, interface, hostname_auth, lease_allocate;
	char *client_hostname, *hostname, *domain, *send_domain;
	struct dhcp_context *context;
	struct in6_addr *link_address, *fallback, *ll_addr, *ula_addr;
	unsigned int xid, fqdn_flags;
	char *iface_name;
	void *packet_options, *end;
	struct dhcp_netid *tags, *context_tags;
	unsigned char mac[DHCP_CHADDR_MAX];
	unsigned int mac_len, mac_type;
#ifdef OPTION6_PREFIX_CLASS
	struct prefix_class *send_prefix_class;
#endif
};
```

So now lets look at  `dhcp6_maybe_reply()` and only focus on `state`. Here is the whole function :

```c

static int dhcp6_maybe_relay(struct state *state, void *inbuff, size_t sz, 
			     struct in6_addr *client_addr, int is_unicast, time_t now)
{
  void *end = inbuff + sz;
  void *opts = inbuff + 34;
  int msg_type = *((unsigned char *)inbuff);
  unsigned char *outmsgtypep;
  void *opt;
  struct dhcp_vendor *vendor;

  /* if not an encapsulated relayed message, just do the stuff */
  if (msg_type != DHCP6RELAYFORW)
    {
      /* if link_address != NULL if points to the link address field of the 
	 innermost nested RELAYFORW message, which is where we find the
	 address of the network on which we can allocate an address.
	 Recalculate the available contexts using that information. 

      link_address == NULL means there's no relay in use, so we try and find the client's 
      MAC address from the local ND cache. */
      
      if (!state->link_address)
	get_client_mac(client_addr, state->interface, state->mac, &state->mac_len, &state->mac_type, now);
      else
	{
	  struct dhcp_context *c;
	  state->context = NULL;
	   
	  if (!IN6_IS_ADDR_LOOPBACK(state->link_address) &&
	      !IN6_IS_ADDR_LINKLOCAL(state->link_address) &&
	      !IN6_IS_ADDR_MULTICAST(state->link_address))
	    for (c = daemon->dhcp6; c; c = c->next)
	      if ((c->flags & CONTEXT_DHCP) &&
		  !(c->flags & (CONTEXT_TEMPLATE | CONTEXT_OLD)) &&
		  is_same_net6(state->link_address, &c->start6, c->prefix) &&
		  is_same_net6(state->link_address, &c->end6, c->prefix))
		{
		  c->preferred = c->valid = 0xffffffff;
		  c->current = state->context;
		  state->context = c;
		}
	  
	  if (!state->context)
	    {
	      inet_ntop(AF_INET6, state->link_address, daemon->addrbuff, ADDRSTRLEN); 
	      my_syslog(MS_DHCP | LOG_WARNING, 
			_("no address range available for DHCPv6 request from relay at %s"),
			daemon->addrbuff);
	      return 0;
	    }
	}
	  
      if (!state->context)
	{
	  my_syslog(MS_DHCP | LOG_WARNING, 
		    _("no address range available for DHCPv6 request via %s"), state->iface_name);
	  return 0;
	}

      return dhcp6_no_relay(state, msg_type, inbuff, sz, is_unicast, now);
    }

  /* must have at least msg_type+hopcount+link_address+peer_address+minimal size option
     which is               1   +    1   +    16      +     16     + 2 + 2 = 38 */
  if (sz < 38)
    return 0;
  
  /* copy header stuff into reply message and set type to reply */
  if (!(outmsgtypep = put_opt6(inbuff, 34)))
    return 0;
  *outmsgtypep = DHCP6RELAYREPL;

  /* look for relay options and set tags if found. */
  for (vendor = daemon->dhcp_vendors; vendor; vendor = vendor->next)
    {
      int mopt;
      
      if (vendor->match_type == MATCH_SUBSCRIBER)
	mopt = OPTION6_SUBSCRIBER_ID;
      else if (vendor->match_type == MATCH_REMOTE)
	mopt = OPTION6_REMOTE_ID; 
      else
	continue;

      if ((opt = opt6_find(opts, end, mopt, 1)) &&
	  vendor->len == opt6_len(opt) &&
	  memcmp(vendor->data, opt6_ptr(opt, 0), vendor->len) == 0 &&
	  vendor->netid.next != &vendor->netid)
	{
	  vendor->netid.next = state->tags;
	  state->tags = &vendor->netid;
	  break;
	}
    }
  
  /* RFC-6939 */
  if ((opt = opt6_find(opts, end, OPTION6_CLIENT_MAC, 3)))
    {
      state->mac_type = opt6_uint(opt, 0, 2);
      state->mac_len = opt6_len(opt) - 2;
      memcpy(&state->mac[0], opt6_ptr(opt, 2), state->mac_len);
    }
  
  for (opt = opts; opt; opt = opt6_next(opt, end))
    {
      int o = new_opt6(opt6_type(opt));
      if (opt6_type(opt) == OPTION6_RELAY_MSG)
	{
	  struct in6_addr align;
	  /* the packet data is unaligned, copy to aligned storage */
	  memcpy(&align, inbuff + 2, IN6ADDRSZ); 
	  state->link_address = &align;
	  /* zero is_unicast since that is now known to refer to the 
	     relayed packet, not the original sent by the client */
	  if (!dhcp6_maybe_relay(state, opt6_ptr(opt, 0), opt6_len(opt), client_addr, 0, now))
	    return 0;
	}
      else if (opt6_type(opt) != OPTION6_CLIENT_MAC)
	put_opt6(opt6_ptr(opt, 0), opt6_len(opt));
      end_opt6(o);	    
    }
  
  return 1;
}
```

Here is where the vulnerability happens: 

```c
if ((opt = opt6_find(opts, end, OPTION6_CLIENT_MAC, 3)))
{
	state->mac_type = opt6_uint(opt, 0, 2);
			state->mac_len = opt6_len(opt) - 2;
	memcpy(&state->mac[0], opt6_ptr(opt, 2), state->mac_len);
}
```

User controlled data is copied to `state->mac[0]` using a user controlled size which is not validated by the program.

Lets check the size of `state->mac`. Has we have seen from the `state struct`.

```c
unsigned char mac[DHCP_CHADDR_MAX];
```

`state->mac` is a character buffer, `DHCP_CHADDR_MAX` is defined with size 16. 

To confirm this vulnerability lets use a debugger to check the size of `state->mac_len` when `memcpy()` is called.

To make this easier I copied the necessary source code into the folder `dnsmasq-2.77/src` and then I used GDB script with the following commands.

```gdb
directory dnsmasq-2.77/src/
set follow-exec-mode new
set breakpoint pending on
b rfc3315.c:211
run -d -i wlp4s0 --dhcp-range=2001:db8::10,2001:db8::ae,64 --enable-ra
```

The above commands makes it easier to debug with source code.
Now lets run the program again.

```sh
sudo gdb ./dnsmasq -x ./gdb_cmds
```



### Patch

Through source patch diffing I found out how they patched this vulnerability.

```c
if ((opt = opt6_find(opts, end, OPTION6_CLIENT_MAC, 3)))
{
	// //
	if (opt6_len(opt) - 2 > DHCP_CHADDR_MAX) {
	return 0;
	}
	// //
	state->mac_type = opt6_uint(opt, 0, 2);
	state->mac_len = opt6_len(opt) - 2;
	memcpy(&state->mac[0], opt6_ptr(opt, 2), state->mac_len);
}
```

I check was added to ensure that the data copied into the `state->mac` buffer was less than `DHCP_CHADDR_MAX`. That is simply the patch.


## CVE-2017-14494

```
./cve-2017-14494.py 2001:db8::1 00030001b24f93313c3500000000
```

## Exploiting.

DHCPv6 message format of a client/server

```
0         7         15         23         31
+------------------------------------------+
|   msg-type  |         transaction-id     |
+------------------------------------------+
|             options(variable)            |
+------------------------------------------+
```


Our goal is to get remote code execution (RCE). To exploit this vulnerability we are gonna need a information leak, in order to bypass security mitigations like ASLR and stack canaries, luckly [CVE-2017-14494]() exists, which is a leak via the same DHCPv6 relay code as [CVE-2017-14493](). 

### CVE-2017-14494


Canary offset: 42 
RBP: 48
RIP: 56
