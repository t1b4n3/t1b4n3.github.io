---
layout: post
title: Off-by-one overflow
description: Explanation on how off-by-one vulnerability on the heap can lead to RCE
date: 2025-11-03
categories:
  - notes
  - heap-exploitation
  - pwn
tags:
  - off-by-one
  - poison-null-byte
  - off-by-null
  - heap-exploitation
  - pwn
---
# off-by-one / poison null byte 

There are 2 types of off by one vulnerabilities: 
1. Arbitrary byte: Allows to overwrite with any value.
2. Poison null byte (off-by-null): Allows to overwrite with only null byte (`0x00`). 

## Examples 

1. Arbitrary byte: 

```c
#include <stdio.h>
#include <string.h>
#define SIZE 1024
int main(int argc, char **argv) {
	if (argc == 2 && strlen(argv[1] > SIZE)) exit(0); 
	
	char *a = malloc(SIZE);
	if (!a) exit(0);
	
	strncpy(a, argv[1], SIZE);	
	
}
```

2. Poison null byte (off-by-null)

```c
#include <stdio.h>
#include <string.h>
#define SIZE 1024
int main(int argc, char **argv) {
	if (argc == 2 && strlen(argv[1] > SIZE)) exit(0); 
	
	char *a = malloc(SIZE);
	if (!a) exit(0);
	// example 1
	int bytesRead = read(0, a, SIZE);
	a[bytesRead] = '\0';
	
	// example 2
	for (int i = 0; i <= SIZE; i++) {
		char c = fgetc(stdin);
		if (c == EOF) a[i] = '\0';
		else a[i] = c;
	}
	// if i reaches SIZE, then the loop continues, buf a[SIZE is out of bounds.
	// since valid index ranges from 0 to SIZE -1.
		
	// example 3
	strncpy(a, argv[1], SIZE);
	a[SIZE] = '\0'; 
	
	// example 4
	
	free(a);
}
```



## Exploitation

Off-by-one / poison null bytes on the heap can lead to code execution by corrupting heap metadata, particularly the `prev_inuse` flag and the previous size field, to create overlapping chunks.

### General off-by-one attack. (arbitrary byte)

1. Allocate 4 chunks.
	- Chunk `A`, `B`, and `C`of any size.
	- Chunk `D` to prevent consolidation.
2. Free chunk `C`
	- It will go to one of the bins based on the size.
3. Use chunk `A` to overflow to the size field of chunk `B`
	- Modify the size field of chunk `B` and make sure the size overlaps with chunk `C`
4. Now chunk `B` will contain the free chunk `C` or its metadata.
5. Free chunk `B` and allocate the same size again.
	- Lets say chunk `B` was `0x20` and we modified it to be `0x40`.
	- Now free chunk `B` and allocate a chunk of size `0x40`. | pass `0x30` to `malloc()`
6. Now the `fd/next` pointer of chunk `C` can be modified or viewed.
	- Can modify the `fd/next` pointer to perform `tcache poisoning` or any other bin attack.
	- If chunk `C` is in unsorted bin, you can view the `fd/bk` and get `libc` leak.

### General poison null byte.

The poison null byte is used to clear the `prev_inuse` flag for chunks that are greater than `0x100. 

Here is why.
- Lets say that we have a chunk of size `0x20`.
- when we try to clear the `prev_inuse` flag we will overwrite the size field from `0x21` to `0x00`.
- Now the chunk will have size `0x00` which is not a valid size field, and the 

Steps

1. Allocate 4 chunks.
	- Chunk `A`, `B`, and `C`of any size.
	- Chunk `D` to prevent consolidation.
2. Use off-by-null vulnerability in  chunk `B` to clear the `prev_inuse` flag in chunk `C`.
3. Set the `prev_size` field on chunk `C` to the size of chunk `A` + `B`. 
	- Lets say the size of  chunk `A` = `0x40` and size of chunk `B` = `0x20`, then set `prev_size` = `0x60`.
4. Free chunk `C`.
	- The chunk will get consolidated with the previous chunk, which is assumed to be size of chunk `A` + `B` (`0x60` is this example) because of the fake `prev_size` field of chunk `C`
5. Allocate a chunk with the same size of chunk `A` - 2 to prevent triggering off-by-one again.
	- This is done to align the big free chunk with chunk `B` and thus store the `FD` and `BK` at the beginning of chunk `B`.
6.  Now you can modify/view the `fd/next` pointer.
	- Can perform other attacks from this.

#### Double free

Requirements
- Use-after-free.
- Poison null byte.

1. Allocate chunk `A` and then free it.
2. Allocate chunk `B` of different size than chunk `A` then free it.
3. Allocate chunk `C` of the same size as chunk `A`.
	- This will return the same chunk as chunk `A`
	- Use off-by-one to overwrite the `prev_inuse` flag of chunk `B`
4. Free chunk `B`
	- Now you have a double free.

You can now use double free for other attacks like `tcache` poisoning or `fastbin dup`.

--- 
## Resources 

- https://devel0pment.de/?p=688