---
layout: post
title: Debugging and exploitation multi-threaded applications
description:
date: 2025-12-30
categories:
  - Guide
tags:
---
## How multi-threaded applications can cause bugs.

- A pointer is passed to the caller's stack as an argument to a new thread.
- Race conditions.



# Debugging



look at the thread information

```sh
info threads
```

Switch between threads

```sh
thread 2
```

Set breakpoints for specific thread

```sh
#break (addr) thread (thread_id)
b func thread 2
```

Set watch points

```sh
# 
```

Looking at  for all threads.

```sh
thread apply all <cmd>
```

example:

back trace for all threads.

```sh
thread apply all bt
```

## Exploitation

Vulnerabilities in multi-threaded programs are often related to concurrent memory management and thread-local data structures. 

The core issue is that checks designed for single-threaded environment can be insufficient if the programme is used in multi-threaded way, allowing concurrency errors to bypass 
security guards.

Multi-threaded applications rely on synchronisation mechanisms, such as mutexes (mutual exclusions), to prevent data corruption during concurrent operations.

In `GLIBC` thread safety is provided by a per-arena mutex that is locked before entering internal routines (like `_int_free())`. This ensures only one execution context operates on critical code sections at a time.

While mutual exclusions protect critical code sections and data from concurrent access while they are in a fragile state, they do not protect against assumptions written into the code base. These assumptions usually involve expecting the certain events happen in a specific order. When these assumptions are violated due to thread interleaving (dividing memory between the threads by allocating segments of it to each thread in turn) , vulnerabilities arise.
### Multi-threaded vulnerability classes

#### Race Conditions

A race condition is : 
#### Use after free.

Thread x invalidates thread y's heap reference.



---

### Canary bypass 

 Override the Canary value stored in `TLS`
 
It is known that Canary is stored in `TLS` and will be compared using this value before the function returns. When the overflow size is large, it can overwrite the Canary and `TLS`stored Canary implementations stored on the stack at the same time.

When a function is has a buffer overflow on a different thread, the thread will have a new stack and the canary is placed on the thread local storage (`TLS`) structure and this structure will be on top of the stack.

`TLS` struct 

```c

```

The `fs` segment register always points to this. We cannot view the address of of which `fs` points to in `gdb`. To view the address we have to use the `arch_prctl` system call which is responsible of setting the  address to the `fs` registers and by viewing the argument of this system call we can find the address of the `TLS` structure.

```sh
catch syscall 158
```

```sh

```

https://vishnudevtj.github.io/notes/star-ctf-2018-babystack