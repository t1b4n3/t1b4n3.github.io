---
layout: post
title: "Devlog #1: Introducing pwntrace | building a syscall tracer from scratch"
description: In this devlog, I introduce my project for tracing and manipulating linux system calls using ptrace. I explain my goals and planned features of the tool.
date: 2025-11-17
categories:
  - devlog
  - pwntrace
tags:
  - devlog
  - pwntrace
---
# Introduction

This is the first entry in my [pwntrace](https://github.com/t1b4n3/pwntrace) devlog, where i explore linux system calls internals by building a tool to trace and manipulate system calls of running processes using `ptrace`. The goal is to understand process execution, how system calls work and how the kernel interacts with user programs. 

Another goal of this project it improve my understanding of process memory, CPU state and system call behaviour, while also improving my programming in `C++` systems programming by building a tool I'll actually use. 
## About the tool.

I call it [pwntrace](https://github.com/t1b4n3/pwntrace). 
Think of the tool as `strace` but with additional features such as system call manipulation and higher level analysis.  
### Planned Features

Here are features I plan to add to the project
1. Basic system call tracing 
2. policy engine.
	- It handles all logic about manipulating system calls 
	- (allow/deny/modify) actions
3. Timeless syscall debugging
	- Produce a replayable traces of program execution
4. Branch Exploration
	- Experiment with different execution paths
5. Differential Analysis
	- Compare execution from two different input states or times.

---
### What it does

 [pwntrace](https://github.com/t1b4n3/pwntrace) intercepts selected system calls of a target process and can:
 - Log them
 - Deny, allow, or modify syscall behaviour dynamically

This makes it similar to `strace`, but with active control instead of read-only tracing.

---
### What can it be used for

#### Reverse Engineering

**Dynamic Analysis**: 
Run a binary under  [pwntrace](https://github.com/t1b4n3/pwntrace). and observe exactly which syscalls it performs, and if it performs malicous things  [pwntrace](https://github.com/t1b4n3/pwntrace).  can change the syscall behaviour.

e.g. if malware is using syscall `open("/etc/passwd", ...)`   [pwntrace](https://github.com/t1b4n3/pwntrace) can change the file name to `open("/tmp/fake_passwd", ...)`

#### Exploit Development

**Controlled Environment for Weaponization**
If a specific syscall crashes your exploit in the lab environment, you can use  [pwntrace](https://github.com/t1b4n3/pwntrace) to stub out that syscall (e.g force it to return success). This allows you to focus on building the rest of the exploit chain without constant interference. 

**Exploit Primitive Augmentation**
You can alter certain syscalls to artificially create new exploit primitives or simulate behaviour normally unavailable in the target environment.

**Post-Exploitation Analysis**
After a successful exploitation, you can run the payload under [pwntrace](https://github.com/t1b4n3/pwntrace) to trace everythng it does. 
This is useful for auditing payload behaviour or analyzing potential untrusted code.

---
## What are system calls?

A system call is a request of service from a program to the kernel of the operating system on which it is executed. This tasks could range from process control (which is what we will be doing), file operations to management of hardware devices.

To build `pwntrace`,I use the `ptrace` syscall.

---

### What does `ptrace` do?

`ptrace` is a syscall that allows one process to control and inspect another process. 

Here is a our we will be using `ptrace` in `C/C++`:
1. Attach to a process

```c
pid_t pid = 1337;
ptrace(PTRACE_ATTACH, pid, NULL, NULL);
waitpid(pid, NULL, 0); // wait for it to stop
```

2. The Syscall Interception Loop

```c
// 
struct user_regs_struct regs;

// set options for detecting syscalls
ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_TRACESYSGOOD |
								PTRACE_O_TRACECLONE | 
								PTRACE_O_TRACEFORK | 
								PTRACE_O_TRACEVFORK);

while (1) {
    ptrace(PTRACE_SYSCALL, pid, NULL, NULL);
    int status;
    waitpid(pid, &status, 0);

    if (!WIFSTOPPED(status))
        break;

    int sig = WSTOPSIG(status);

    // syscall-stop: SIGTRAP | 0x80
    if (sig == (SIGTRAP | 0x80)) {
        ptrace(PTRACE_GETREGS, pid, NULL, &regs);

        int syscall_no = regs.orig_rax;
        long arg1 = regs.rdi;
        long arg2 = regs.rsi;
        long arg3 = regs.rdx;

        printf("syscall %d (%llx, %llx, %llx)\n",
               syscall_no, arg1, arg2, arg3);
    }
}
```

3. Detach the process

```c
ptrace(PTRACE_DETACH, pid, NULL, NULL);
```

---

## Up Next

I will continue documenting the process as I build `pwntrace`'s core features. The next devlog will focus on tracing registers, dumping syscalls along with their arguments and return value, and building a event loop.

If you want to follow along or contribute, [the repository is here]( https://github.com/t1b4n3/pwntrace)

---
## Resources

- [Repository](https://github.com/t1b4n3/pwntrace)
- [Linux man page (`ptrace`)](https://man7.org/linux/man-pages/man2/ptrace.2.html)
- [System calls](https://en.wikipedia.org/wiki/System_call)