---
layout: post
title: File Stream Oriented Programming
description:
date: 2025-11-10
categories:
  - notes
  - rop
tags:
  - File-Struct-Exploits
  - fsop
---
## File structure
The file structure is a important component of that standard I/O library in C, representing a file stream. 
`_IO_FILE`
```c
/* The tag name of this struct is _IO_FILE to preserve historic
   C++ mangled names for functions taking FILE* arguments.
   That name should not be used in new code.  */
struct _IO_FILE
{
  int _flags;		/* High-order word is _IO_MAGIC; rest is flags. */

  /* The following pointers correspond to the C++ streambuf protocol. */
  char *_IO_read_ptr;	/* Current read pointer */
  char *_IO_read_end;	/* End of get area. */
  char *_IO_read_base;	/* Start of putback+get area. */
  char *_IO_write_base;	/* Start of put area. */
  char *_IO_write_ptr;	/* Current put pointer. */
  char *_IO_write_end;	/* End of put area. */
  char *_IO_buf_base;	/* Start of reserve area. */
  char *_IO_buf_end;	/* End of reserve area. */

  /* The following fields are used to support backing up and undo. */
  char *_IO_save_base; /* Pointer to start of non-current get area. */
  char *_IO_backup_base;  /* Pointer to first valid character of backup area */
  char *_IO_save_end; /* Pointer to end of non-current get area. */

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2;
  __off_t _old_offset; /* This used to be _offset but it's too small.  */

  /* 1+column number of pbase(); 0 is unknown. */
  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;
#ifdef _IO_USE_OLD_IO_FILE
};

struct _IO_FILE_complete
{
  struct _IO_FILE _file;
#endif
  __off64_t _offset;
  /* Wide character stream stuff.  */
  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;
  /* Make sure we don't get into trouble again.  */
  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};

```

`_flags` is used to record the attribute of File stream such as read only, write, append and so on. It also shows the status of the file buffering status.

```
/* Magic number and bits for the _flags field.  The magic number is
   mostly vestigial, but preserved for compatibility.  It occupies the
   high 16 bits of _flags; the low 16 bits are actual flag bits.  */

#define _IO_MAGIC         0xFBAD0000 /* Magic number */
#define _IO_MAGIC_MASK    0xFFFF0000
#define _IO_USER_BUF          0x0001 /* Don't deallocate buffer on close. */
#define _IO_UNBUFFERED        0x0002
#define _IO_NO_READS          0x0004 /* Reading not allowed.  */
#define _IO_NO_WRITES         0x0008 /* Writing not allowed.  */
#define _IO_EOF_SEEN          0x0010
#define _IO_ERR_SEEN          0x0020
#define _IO_DELETE_DONT_CLOSE 0x0040 /* Don't call close(_fileno) on close.  */
#define _IO_LINKED            0x0080 /* In the list of all open files.  */
#define _IO_IN_BACKUP         0x0100
#define _IO_LINE_BUF          0x0200
#define _IO_TIED_PUT_GET      0x0400 /* Put and get pointer move in unison.  */
#define _IO_CURRENTLY_PUTTING 0x0800
#define _IO_IS_APPENDING      0x1000
#define _IO_IS_FILEBUF        0x2000
                           /* 0x4000  No longer used, reserved for compat.  */
#define _IO_USER_LOCK         0x8000


```


Stream buffer pointer is divided into three parts:
1. read buffer.
	- (`_IO_read_ptr`, `_IO_read_end`, `_IO_read_base`)
2. write buffer.
	- (`_IO_write_ptr`, `_IO_write_end,` `_IO_write_base`)
3. reserve buffer.
	- (`_IO_buf_base`, `_IO_buf_end`)

Where the pointers point to:
- `**ptr` points at the current buffer position.
- `**base` points to the beginning of the buffer.
- `**end` points to the end of the buffer.

`_fileno` is a file descriptor from the file which you open, it returns from the system call `open`. 

Then there is `_IO_FILE_plus` which is an extension of the FILE structure. It adds the virtual function table also called `vtable`.
`_IO_FILE_plus`
```c
/* We always allocate an extra word following an _IO_FILE.
   This contains a pointer to the function jump table used.
   This is for compatibility with C++ streambuf; the word can
   be used to smash to a pointer to a virtual function table. */

struct _IO_FILE_plus
{
  FILE file;
  const struct _IO_jump_t *vtable;
};

```

Default file streams (`stdin`, `stdout`, `stderr`) use this extended version. The purpose of using the extended version `_IO_FILE_plus` is to make IO operations faster by having the `vtable`.
### Virtual Function Table

 Array of pointers to the helper functions during executing the IO operation. It is commonly found in `C++` binaries. `vtables` allows for dynamic function resolution at runtime.  The data type for the `vtable` is `_IO_jump_t` which stores the pointer to the needed IO helper methods.

`_IO_jump_t`
```c
struct _IO_jump_t
{
    JUMP_FIELD(size_t, __dummy);
    JUMP_FIELD(size_t, __dummy2);
    JUMP_FIELD(_IO_finish_t, __finish);
    JUMP_FIELD(_IO_overflow_t, __overflow);
    JUMP_FIELD(_IO_underflow_t, __underflow);
    JUMP_FIELD(_IO_underflow_t, __uflow);
    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);
    /* showmany */
    JUMP_FIELD(_IO_xsputn_t, __xsputn);
    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);
    JUMP_FIELD(_IO_seekoff_t, __seekoff);
    JUMP_FIELD(_IO_seekpos_t, __seekpos);
    JUMP_FIELD(_IO_setbuf_t, __setbuf);
    JUMP_FIELD(_IO_sync_t, __sync);
    JUMP_FIELD(_IO_doallocate_t, __doallocate);
    JUMP_FIELD(_IO_read_t, __read);
    JUMP_FIELD(_IO_write_t, __write);
    JUMP_FIELD(_IO_seek_t, __seek);
    JUMP_FIELD(_IO_close_t, __close);
    JUMP_FIELD(_IO_stat_t, __stat);
    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);
    JUMP_FIELD(_IO_imbue_t, __imbue);
};
```

Very FILE structure is associated with a linked list and the head of the linked list is called `_IO_list_all` and the next pointer is called `_chain`


--- 

## Protections

glibc 2.24 - Added memory check for `vtable`
The `vtable` pointer has to be within a memory area within `glibc` 

glibc 2.26 - The `vtable` is moved within a non-writable memory location.

glibc 2.29 - The `vtable` is moved back to writable location

---
## Exploitation

### Arbitrary Write **(Reading Data In)**

Requirements
- Set flag value
- set `read_ptr` = `read_end`
- set `buf_base` to address to write
- set `buf_end` to address to write + length (end point)
- `buf_end` - `buf_base` >= number of bytes to read

We use `fread` to read bytes from `stdin` to a buffer

```c
FILE *fp = fopen("./flag.txt", "r");
read(0, fp, 0x100);
char buf[0x100];
fread(buf, 1, 10, fp);
```

`Pwntools`
```python
addr = 0xdeadbeef # address to write
size = 0x10 # must be larger than bytes read on `fread`
fp = FileStructure()
payload = fp.read(addr, size)
```

### Arbitrary Read **(Writing Data Out)**

Requirements
- set flag value
- set `write_base` to memory to write
- set `write_ptr` to address to write+length
- set `read_end` = `write_base`
- `buf_end` - `buf_base` >= number of bytes to write

We use the `fwrite` function to write a buffer to `stdout`

```c
FILE *fp = fopen("file", "w");
char buf[0x100];
fwrite(buf, 1, 40, fp);
```

`Pwntools`
```python
addr = 0xdeadbeef # address to read
size = 0x10 # must be larger than bytes written on `fwrite`
fp = FileStructure()
payload = fp.write(addr, size)
```

### `vtable` hijacking

the `_IO_jump_` table is full of function pointers which are needed for object oriented programming, if you can overwrite a function pointer inside the `vtable` of a file stream then trigger that function you can control the instruction pointer.


Create our own fake `vtable`, it can be placed anywhere. The place desired execution address at correct offset and then overwrite the `vtable` pointer in the `_IO_File` struct to point to our fake `vtable`. Make sure the `_IO_lock_t`.

`_IO_lock_t` pointer is used in multi-threaded programs to prevent race conditions. An exploit must set `_IO_lock_t` to point to:
- writable location
- with value NULL

```
p *_IO_list_all.file._wide_data._wide_vtable
```

overwrite one of the functions in  `file._wide_data._wide_vtable` that will be called. 

---

## FSOP

Control the linked list of file stream
- `_chain`
- `_IO_list_all`

Powerful function
- `_IO_flush_all_lockp`


### `__IO_fluch_all_lockp`


Flushes all file streams.

It is called when `glibc` aborts, by `exit()` or when `main()` returns










---

## References

- [file struct attack](https://chovid99.github.io/posts/file-structure-attack-part-1/#the-usage-of-vtable-in-a-file-structure)
- https://niftic.ca/posts/fsop/
- [angry-fsop](http://blog.kylebot.net/2022/10/22/angry-FSROP/)